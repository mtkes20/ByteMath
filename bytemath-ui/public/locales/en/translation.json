{
  "title": "Math for Computer Science",
  "courses": "Courses",
  "signIn": "Sign In",
  "signOut": "Sign Out",
  "introduction_to_logical_operators_title": "Introduction to Logical Operators",
  "calculate": "Calculate",
  "binarySystemTitle": "Binary System",
  "logicalOperandsTitle": "Logical Operands",
  "graphTheoryTitle": "Theory of Graphs",
  "numberTheoryTitle": "Theory of Numbers",
  "introduction": "Introduction",
  "lcm-gcd": "LCM and GCD",
  "rsa-algorithm": "RSA Algorithm",
  "modular-arithmetic": "Modular Arithmetic",
  "quizResults": "Quiz Results",
  "question": "Question",
  "yourAnswer": "Your Answer",
  "correctAnswer": "Correct Answer",
  "totalScore": "Total Score",
  "tryAgain": "Try Again",
  "correct": "Correct",
  "incorrect": "Incorrect",
  "decimalValue": "Decimal Value",
  "converting": "Converting",
  "binaryArithmetic": "Binary Arithmetic",
  "clickToExplore": "Click to explore this course",
  "welcome": "Welcome",
  "complete": "Complete",
  "result": "Result",
  "wantToTakeQuiz": "Want to take a quiz?",
  "viewResults": "View Results",
  "problems": {
    "selectProblem": "Select a Problem",
    "description": "Description:",
    "difficulty": "Difficulty:",
    "task": "Task:",
    "inputFormat": "Input Format:",
    "outputFormat": "Output Format:",
    "example": "Example:",
    "note": "Note:",
    "language": "Language",
    "runCode": "Run Code",
    "running": "Running...",
    "output": "Output:",
    "testCase": "Test Case",
    "testCaseSuccessful": "Successful",
    "testCaseFailed": "Failed",
    "expectedResult": "Expected",
    "gotResult": "Got",
    "codeAndTestsRunning": "Running code and tests..."
  },
  "binarySystem": {
    "introduction": {
      "title": "Understanding the Binary System",
      "introduction": "The binary system, also known as the base-2 numeral system, is fundamental to computer science and digital electronics. It forms the foundation of all digital data representation and processing.",
      "fundamentals": {
        "title": "Fundamentals of Binary",
        "description": "The binary system is based on two digits: 0 and 1, known as bits (binary digits). Here are some key points:",
        "points": [
          "Binary uses only two digits compared to decimal's ten digits.",
          "Each digit position represents a power of 2.",
          "The rightmost digit represents 2^0 (1), the next 2^1 (2), then 2^2 (4), and so on.",
          "Binary numbers can represent any quantity that decimal numbers can."
        ]
      },
      "whyBinary": {
        "title": "Why Binary is Used in Computing",
        "description": "Binary is the language of computers for several reasons:",
        "points": [
          "Electronic circuits have two stable states, making binary a natural fit.",
          "It's easier and more reliable to distinguish between two states than multiple states.",
          "Binary operations can be implemented efficiently with digital logic gates.",
          "Error detection and correction are simpler with a binary system."
        ]
      },
      "binaryNumbers": {
        "title": "Understanding Binary Numbers",
        "description": "Binary numbers work similarly to decimal numbers, but with a base of 2 instead of 10:",
        "points": [
          "The binary number 1011 is equivalent to the decimal number 11 (1*2^3 + 0*2^2 + 1*2^1 + 1*2^0).",
          "Each additional bit doubles the range of numbers that can be represented.",
          "8 bits (a byte) can represent numbers from 0 to 255.",
          "Leading zeros don't change the value of a binary number."
        ]
      },
      "binaryOperations": {
        "title": "Basic Binary Operations",
        "description": "Arithmetic in binary follows similar rules to decimal, but with only two digits:",
        "points": [
          "Addition: 1 + 1 = 10 in binary (carry the 1)",
          "Subtraction: Borrow from the next column when needed",
          "Multiplication: Similar to decimal, but simpler as you only multiply by 0 or 1",
          "Division: Can be performed through repeated subtraction and shifting"
        ]
      },
      "applications": {
        "title": "Applications of the Binary System",
        "description": "The binary system is crucial in many areas of computing and technology:",
        "points": [
          "Data Storage: All data in computers is ultimately stored in binary.",
          "Digital Logic: Computer processors use binary for all their operations.",
          "Networking: Data transmission over networks uses binary encoding.",
          "Image and Sound Processing: Digital media is represented and processed in binary.",
          "Cryptography: Many encryption algorithms rely on binary operations."
        ]
      }
    },
    "binaryConversion": {
      "title": "Advanced Binary Conversion",
      "introduction": "Binary conversion is a fundamental skill in computer science and digital systems. Understanding the process of converting between binary and decimal systems is crucial for working with computers at a low level.",
      "binaryToDecimal": {
        "title": "Converting Binary to Decimal",
        "description": "To convert a binary number to decimal, sum the products of each bit and its corresponding power of 2. The rightmost bit corresponds to 2^0, the next to 2^1, and so on.",
        "example": "Example: 1011 (binary) = (1 * 2^3) + (0 * 2^2) + (1 * 2^1) + (1 * 2^0) = 8 + 0 + 2 + 1 = 11 (decimal)"
      },
      "decimalToBinary": {
        "title": "Converting Decimal to Binary",
        "description": "To convert a decimal number to binary, repeatedly divide the number by 2 and record the remainders. The binary representation is the sequence of remainders read from bottom to top.",
        "example": "Example: 11 (decimal) to binary:\n11 / 2 = 5 remainder 1\n5 / 2 = 2 remainder 1\n2 / 2 = 1 remainder 0\n1 / 2 = 0 remainder 1\nReading from bottom to top: 1011 (binary)"
      },
      "fractions": {
        "title": "Binary Fractions and Floating-Point Numbers",
        "description": "Binary can also represent fractional numbers. For the fractional part, multiply by 2 repeatedly, taking the integer part each time as the next binary digit.",
        "example": "Example: 0.625 (decimal) to binary:\n0.625 * 2 = 1.25 (1)\n0.25 * 2 = 0.5 (0)\n0.5 * 2 = 1.0 (1)\nResult: 0.101 (binary)"
      },
      "negativeNumbers": {
        "title": "Representing Negative Numbers",
        "description": "Computers typically use two's complement to represent negative numbers. To find the two's complement of a number, invert all bits and add 1.",
        "example": "Example: -5 in 8-bit two's complement:\n5 in binary: 00000101\nInvert all bits: 11111010\nAdd 1: 11111011\nSo -5 is represented as 11111011 in two's complement"
      },
      "applications": {
        "title": "Practical Applications",
        "description": "Understanding binary conversion is crucial in many areas of computing:",
        "list": [
          "Digital circuit design and analysis",
          "Low-level programming and embedded systems",
          "Network protocols and data transmission",
          "Cryptography and data security",
          "Computer graphics and image processing"
        ]
      },
      "advancedTopics": {
        "title": "Advanced Binary Topics",
        "description": "Beyond basic conversion, there are several advanced topics related to binary representation:",
        "list": [
          "IEEE 754 floating-point representation",
          "Binary Coded Decimal (BCD)",
          "Gray code and its applications",
          "Hexadecimal as a compact representation of binary",
          "Error detection and correction codes (e.g., Hamming codes)"
        ]
      },
      "calculator": {
        "binary": "Binary",
        "decimal": "Decimal",
        "enterBinaryNumber": "Enter binary number",
        "enterDecimalNumber": "Enter decimal number"
      }
    },
    "binaryArithmetic": {
      "title": "გაღრმავებული ორობითი არითმეტიკა",
      "introduction": "ორობითი არითმეტიკა მუშაობს ათობითი არითმეტიკის მსგავსად, მაგრამ მიჰყვება ორობითი რიცხვითი სისტემის წესებს. ამ ოპერაციების გაგება მნიშვნელოვანია დაბალი დონის პროგრამირებისა და კომპიუტერის არქიტექტურისთვის.",
      "addition": {
        "title": "ორობითი შეკრება",
        "description": "ორობითი შეკრება ათობითი შეკრების მსგავსია, მაგრამ მხოლოდ ორი ციფრით. მთავარია გვახსოვდეს, რომ 1 + 1 ორობითში უდრის 10-ს (2-ს ათობითში).",
        "table": [
          {
            "A": "0",
            "B": "0",
            "ჯამი": "0",
            "გადატანა": "0"
          },
          {
            "A": "0",
            "B": "1",
            "ჯამი": "1",
            "გადატანა": "0"
          },
          {
            "A": "1",
            "B": "0",
            "ჯამი": "1",
            "გადატანა": "0"
          },
          {
            "A": "1",
            "B": "1",
            "ჯამი": "0",
            "გადატანა": "1"
          }
        ],
        "example": "მაგალითი: 1011-ისა და 1101-ის შეკრება\n  1011\n+ 1101\n------\n 10100"
      },
      "subtraction": {
        "title": "ორობითი გამოკლება",
        "description": "ორობითი გამოკლება მიჰყვება ათობითი გამოკლების მსგავს პრინციპებს, საჭიროების შემთხვევაში სესხებით.",
        "table": [
          {
            "A": "0",
            "B": "0",
            "სხვაობა": "0",
            "სესხი": "0"
          },
          {
            "A": "0",
            "B": "1",
            "სხვაობა": "1",
            "სესხი": "1"
          },
          {
            "A": "1",
            "B": "0",
            "სხვაობა": "1",
            "სესხი": "0"
          },
          {
            "A": "1",
            "B": "1",
            "სხვაობა": "0",
            "სესხი": "0"
          }
        ],
        "example": "მაგალითი: 1011-ის გამოკლება 1101-დან\n  1101\n- 1011\n------\n  0010"
      },
      "multiplication": {
        "title": "ორობითი გამრავლება",
        "description": "ორობითი გამრავლება უფრო მარტივია ვიდრე ათობითი გამრავლება, რადგან მხოლოდ 0-ებსა და 1-ებს მოიცავს.",
        "table": [
          {
            "A": "0",
            "B": "0",
            "ნამრავლი": "0"
          },
          {
            "A": "0",
            "B": "1",
            "ნამრავლი": "0"
          },
          {
            "A": "1",
            "B": "0",
            "ნამრავლი": "0"
          },
          {
            "A": "1",
            "B": "1",
            "ნამრავლი": "1"
          }
        ],
        "example": "მაგალითი: 101-ის გამრავლება 11-ზე\n  101\n×  11\n-----\n  101\n 101\n-----\n 1111"
      },
      "division": {
        "title": "ორობითი გაყოფა",
        "description": "ორობითი გაყოფა მიჰყვება ათობითი გაყოფის იმავე პრინციპებს, მაგრამ იყენებს ორობით რიცხვებს.",
        "example": "მაგალითი: 1010-ის გაყოფა 10-ზე\n  101\n-------\n10 | 1010\n    - 10\n    ----\n      10\n     -10\n    ----\n       0"
      },
      "advancedTopics": {
        "title": "გაღრმავებული ორობითი არითმეტიკის კონცეფციები",
        "description": "ძირითადი ოპერაციების გარდა, არსებობს რამდენიმე გაღრმავებული თემა ორობით არითმეტიკაში:",
        "list": [
          "ორის შევსების წარმოდგენა ნიშნიანი მთელი რიცხვებისთვის",
          "მცურავი წერტილის არითმეტიკა (IEEE 754 სტანდარტი)",
          "ბიტური ოპერაციები (AND, OR, XOR, NOT)",
          "არითმეტიკული და ლოგიკური წანაცვლებები",
          "მიმდევრობითი გადატანის შემკრები და სხვა სწრაფი შეკრების ტექნიკები",
          "ბუთის გამრავლების ალგორითმი",
          "არააღდგენითი გაყოფის ალგორითმი"
        ]
      },
      "applications": {
        "title": "ორობითი არითმეტიკის გამოყენებები",
        "description": "ორობითი არითმეტიკა ფუნდამენტურია კომპიუტინგის მრავალ სფეროში:",
        "list": [
          "ALU-ს (არითმეტიკულ-ლოგიკური მოწყობილობა) დიზაინი პროცესორებში",
          "მცურავი წერტილის თანაპროცესორები",
          "ციფრული სიგნალების დამუშავება",
          "კრიპტოგრაფიული ალგორითმები",
          "შეცდომების აღმოჩენისა და გასწორების კოდები",
          "კომპიუტერული გრაფიკა (მაგ., მატრიცული ოპერაციები)",
          "მანქანური სწავლების აქსელერატორები"
        ]
      },
      "calculator": {
        "enterFirstBinary": "შეიყვანეთ პირველი ორობითი რიცხვი",
        "enterSecondBinary": "შეიყვანეთ მეორე ორობითი რიცხვი"
      }
    }
  },
  "logicalOperands": {
    "title": "Logical Operands",
    "introduction": {
      "title": "Introduction",
      "description": "Logical operators are fundamental concepts in discrete mathematics and computer science. They allow us to create complex conditions, make decisions in programming, and form the basis of boolean algebra.",
      "moduleExploration": {
        "header": "In this module, you'll explore:",
        "items": [
          "Basic Logical Operators",
          "Advanced Logical Operators",
          "Truth Tables"
        ]
      },
      "understandingImportance": {
        "header": "Understanding logical operators is crucial for several reasons:",
        "items": [
          "They are essential in programming for creating conditional statements and controlling program flow.",
          "They form the basis of digital circuit design in computer hardware.",
          "They are used extensively in database systems for constructing complex queries.",
          "They play a key role in artificial intelligence, particularly in decision-making algorithms."
        ]
      },
      "progressNote": "As you progress through this module, you'll gain a solid foundation in logical operators, preparing you for more advanced topics in computer science and discrete mathematics."
    },
    "basicOperators": {
      "title": "Basic Logical Operators",
      "introduction": "Logical operators are fundamental to programming and boolean logic. They allow us to make complex decisions based on multiple conditions. Let's explore the three basic logical operators:",
      "and": {
        "title": "AND (&&)",
        "description": "Returns true (1) if both operands are true, otherwise false (0).",
        "explanation": "The AND operator is used when you want to check if multiple conditions are all true. It's like checking if you have both your keys AND your wallet before leaving the house."
      },
      "or": {
        "title": "OR (||)",
        "description": "Returns true (1) if at least one operand is true, otherwise false (0).",
        "explanation": "The OR operator is used when you want to check if at least one of multiple conditions is true. It's like deciding to go for a walk if it's either sunny OR you have an umbrella."
      },
      "not": {
        "title": "NOT (!)",
        "description": "Inverts the truth value of the operand.",
        "explanation": "The NOT operator is used to reverse a boolean value. It's like a light switch: if the light is on, NOT will turn it off, and if it's off, NOT will turn it on."
      },
      "interactionPrompt": "Try it out: Click the bits below to toggle between 0 (false) and 1 (true)",
      "result": "Result"
    },
    "advancedOperators": {
      "title": "Advanced Logical Operators",
      "description": "Advanced logical operators build upon the basic ones, offering more complex and powerful ways to manipulate logical conditions. These operators are invaluable in scenarios requiring complex condition checks, digital circuit design, and succinct conditional logic expressions.",
      "xor": {
        "title": "XOR (^)",
        "description": "Returns true if the operands are different, false if they are the same.",
        "explanation": "XOR (Exclusive OR) is useful when you want to check if exactly one of two conditions is true, but not both."
      },
      "nand": {
        "title": "NAND",
        "description": "Returns false only if both operands are true.",
        "explanation": "NAND is the negation of AND. It's often used in digital circuit design as a universal gate."
      },
      "nor": {
        "title": "NOR",
        "description": "Returns true only if both operands are false.",
        "explanation": "NOR is the negation of OR. Like NAND, it's also used as a universal gate in digital circuits."
      },
      "interactionPrompt": "Try it out: Click the bits below to toggle between 0 (false) and 1 (true)",
      "result": "Result"
    },
    "truthTables": {
      "title": "Truth Tables",
      "description": "Logical operators are fundamental to programming and boolean logic. They allow us to evaluate expressions and make complex decisions. Below are the truth tables for the fundamental logic gates:",
      "and": {
        "name": "AND",
        "symbol": "&&",
        "description": "Returns true if both operands are true.",
        "explanation": "The AND operator is used when you want to check if multiple conditions are all true. It's like checking if you have both your keys AND your wallet before leaving the house."
      },
      "or": {
        "name": "OR",
        "symbol": "||",
        "description": "Returns true if at least one of the operands is true.",
        "explanation": "The OR operator is used when you want to check if at least one of multiple conditions is true. It's like deciding to go for a walk if it's either sunny OR you have an umbrella."
      },
      "not": {
        "name": "NOT",
        "symbol": "!",
        "description": "Inverts the truth value of the operand.",
        "explanation": "The NOT operator is used to reverse a boolean value. It's like a light switch: if the light is on, NOT will turn it off, and if it's off, NOT will turn it on."
      },
      "xor": {
        "name": "XOR",
        "symbol": "⊕",
        "description": "Returns true if exactly one of the operands is true.",
        "explanation": "The XOR (exclusive OR) operator returns true only when exactly one of its inputs is true. It's like a 'one or the other, but not both' situation."
      },
      "tableHeaderA": "A",
      "tableHeaderB": "B",
      "tableHeaderResult": "Result"
    }
  },
  "numberTheory": {
    "introduction": {
      "title": "Introduction to the Theory of Numbers",
      "description": "The Theory of Numbers, also known as Number Theory, is a branch of pure mathematics devoted primarily to the study of the integers and integer-valued functions. It is one of the oldest and most fundamental areas of mathematics, with a rich history dating back to ancient civilizations.",
      "keyConcepts": {
        "title": "Key Concepts in Number Theory:",
        "list": [
          "Prime Numbers: Numbers greater than 1 that have no positive divisors other than 1 and themselves.",
          "Divisibility: The study of when one integer is divisible by another.",
          "Greatest Common Divisor (GCD): The largest positive integer that divides each of the numbers without a remainder.",
          "Least Common Multiple (LCM): The smallest positive integer that is divisible by each of the numbers.",
          "Modular Arithmetic: Arithmetic that deals with the remainders after division.",
          "Diophantine Equations: Polynomial equations where only integer solutions are sought."
        ]
      },
      "applications": {
        "title": "Applications of Number Theory:",
        "list": [
          "Cryptography: Many encryption methods, including RSA, are based on number theory principles.",
          "Computer Science: Algorithms, data structures, and error-correcting codes often rely on number theory concepts.",
          "Physics: Number theory is used in various areas of theoretical physics, including string theory.",
          "Engineering: Applications in signal processing, control theory, and other engineering fields."
        ]
      },
      "conclusion": "Number theory continues to be an active area of research, with many unsolved problems and conjectures that have puzzled mathematicians for centuries."
    },
    "lcmAndGcd": {
      "title": "Least Common Multiple (LCM) and Greatest Common Divisor (GCD)",
      "whatAre": {
        "title": "What are LCM and GCD?",
        "lcm": {
          "title": "Least Common Multiple (LCM)",
          "description": "The LCM of two or more integers is the smallest positive integer that is divisible by each of the integers. For example, the LCM of 4 and 6 is 12."
        },
        "gcd": {
          "title": "Greatest Common Divisor (GCD)",
          "description": "The GCD of two or more integers is the largest positive integer that divides each of the integers without a remainder. For example, the GCD of 8 and 12 is 4."
        }
      },
      "importance": {
        "title": "Why are LCM and GCD important?",
        "list": [
          "LCM is used in many areas of mathematics, including fractions, algebra, and number theory.",
          "GCD is fundamental in simplifying fractions, solving Diophantine equations, and in various algorithms in computer science.",
          "Both LCM and GCD are crucial in cryptography, particularly in the RSA algorithm.",
          "In computer programming, LCM and GCD are used in various algorithms and data structures."
        ]
      },
      "calculation": {
        "title": "How to Calculate LCM and GCD",
        "gcd": {
          "title": "Calculating GCD",
          "description": "The most efficient method to calculate GCD is the Euclidean algorithm:",
          "steps": [
            "Divide the larger number by the smaller one.",
            "Replace the larger number with the smaller number and the smaller number with the remainder from step 1.",
            "Repeat until the remainder is zero. The last non-zero remainder is the GCD."
          ]
        },
        "lcm": {
          "title": "Calculating LCM",
          "description": "LCM can be calculated using the formula:",
          "formula": "LCM(a, b) = |a * b| / GCD(a, b)",
          "note": "Where |a * b| denotes the absolute value of a * b."
        }
      },
      "examples": {
        "title": "Examples",
        "gcd": {
          "title": "GCD Example: Calculate GCD(48, 18)",
          "steps": [
            "48 ÷ 18 = 2 remainder 12",
            "18 ÷ 12 = 1 remainder 6",
            "12 ÷ 6 = 2 remainder 0",
            "The last non-zero remainder is 6, so GCD(48, 18) = 6"
          ]
        },
        "lcm": {
          "title": "LCM Example: Calculate LCM(12, 18)",
          "steps": [
            "First, calculate GCD(12, 18) = 6",
            "Then, LCM(12, 18) = |12 * 18| / 6 = 216 / 6 = 36"
          ]
        }
      },
      "calculator": {
        "enterFirstNumber": "Enter first number",
        "enterSecondNumber": "Enter second number",
        "lcm": "LCM",
        "gcd": "GCD"
      }
    },
    "modularArithmetic": {
      "title": "Modular Arithmetic",
      "introduction": {
        "title": "What is Modular Arithmetic?",
        "description": "Modular arithmetic is a system of arithmetic for integers, where numbers \"wrap around\" after reaching a certain value — the modulus. It's often described as \"clock arithmetic\" because it's similar to how hours on a clock wrap around from 12 back to 1."
      },
      "keyConcepts": {
        "title": "Key Concepts",
        "list": [
          "Congruence: We say a is congruent to b modulo m if m divides (a-b). We write this as a ≡ b (mod m).",
          "Modular Addition: (a + b) mod m = ((a mod m) + (b mod m)) mod m",
          "Modular Subtraction: (a - b) mod m = ((a mod m) - (b mod m) + m) mod m",
          "Modular Multiplication: (a * b) mod m = ((a mod m) * (b mod m)) mod m",
          "Modular Exponentiation: a^b mod m = ((a mod m)^b) mod m"
        ]
      },
      "applications": {
        "title": "Applications",
        "description": "Modular arithmetic has many applications in computer science and cryptography:",
        "list": [
          "Hash functions",
          "Random number generation",
          "Error detection and correction codes",
          "Cryptographic algorithms (like RSA)"
        ]
      },
      "calculator": {
        "title": "Modular Arithmetic Calculator",
        "result": "Result: {{a}} {{operation}} {{b}} ≡ {{result}} (mod {{m}})"
      }
    },
    "rsaAlgorithm": {
      "title": "RSA Algorithm",
      "whatIsRSA": {
        "title": "What is RSA?",
        "description1": "RSA (Rivest-Shamir-Adleman) is a public-key cryptosystem that is widely used for secure data transmission. It is an asymmetric cryptographic algorithm, meaning it uses two different keys: a public key for encryption and a private key for decryption.",
        "description2": "RSA was first described in 1977 by Ron Rivest, Adi Shamir, and Leonard Adleman at MIT. The letters RSA are the initials of their surnames. It was one of the first practical public-key cryptosystems and is still widely used for secure data transmission."
      },
      "importance": {
        "title": "Importance of RSA",
        "list": [
          "Security: RSA's security is based on the practical difficulty of factoring the product of two large prime numbers, known as the factoring problem.",
          "Digital Signatures: RSA can be used to create digital signatures, ensuring the authenticity and integrity of digital messages or documents.",
          "Key Exchange: It enables secure exchange of keys over insecure channels, which is crucial for establishing secure communication.",
          "Widespread Use: RSA is used in many protocols, including SSL/TLS, which is used to secure internet communications."
        ]
      },
      "howItWorks": {
        "title": "How RSA Works: Detailed Steps",
        "keyGeneration": {
          "title": "1. Key Generation:",
          "steps": [
            "Choose two distinct large prime numbers p and q.",
            "Compute n = p * q. This n is called the modulus for both the public and private keys.",
            "Compute φ(n) = (p-1) * (q-1). This is Euler's totient function.",
            "Choose an integer e such that 1 < e < φ(n) and gcd(e, φ(n)) = 1. This e is the public exponent.",
            "Compute d as the modular multiplicative inverse of e (mod φ(n)). This d is the private exponent."
          ]
        },
        "keyDistribution": {
          "title": "2. Key Distribution:",
          "steps": [
            "The public key is (e, n). This can be known to everyone and is used for encryption.",
            "The private key is (d, n). This must be kept secret and is used for decryption."
          ]
        },
        "encryption": {
          "title": "3. Encryption:",
          "steps": [
            "Convert the message into a number m, where 0 ≤ m < n.",
            "Compute the ciphertext c = m^e mod n."
          ]
        },
        "decryption": {
          "title": "4. Decryption:",
          "steps": [
            "Use the private key (d, n) to compute m = c^d mod n.",
            "Convert m back to the original message."
          ]
        }
      },
      "mathematicalFoundation": {
        "title": "Mathematical Foundation",
        "description": "The security of RSA relies on two mathematical facts:",
        "fact1": "1. Modular Exponentiation: It's computationally easy to calculate n = p * q and c = m^e mod n.",
        "fact2": "2. Prime Factorization: It's computationally difficult to determine p and q from n, especially when p and q are large primes.",
        "additional": "The algorithm also relies on Euler's theorem and the properties of modular arithmetic to ensure that encryption and decryption are inverse operations."
      },
      "securityConsiderations": {
        "title": "Security Considerations",
        "list": [
          "Key Size: The security of RSA depends on the size of n. As of 2021, a key size of 2048 bits is considered secure for most applications.",
          "Prime Number Generation: The prime numbers p and q must be generated randomly and kept secret.",
          "Padding: In practice, RSA is often used with padding schemes like OAEP to enhance security.",
          "Side-Channel Attacks: Implementations must be careful to avoid leaking information through timing or power consumption."
        ]
      },
      "practicalExample": {
        "title": "Practical Example",
        "description": "Let's walk through a simple example with small numbers (note: in practice, much larger numbers are used):",
        "steps": [
          "Choose p = 61 and q = 53",
          "Calculate n = 61 * 53 = 3233",
          "Calculate φ(n) = (61-1) * (53-1) = 3120",
          "Choose e = 17 (coprime with 3120)",
          "Find d such that (d * 17) mod 3120 = 1. d = 2753",
          "Public key is (17, 3233), Private key is (2753, 3233)",
          "To encrypt m = 123: c = 123^17 mod 3233 = 855",
          "To decrypt c = 855: m = 855^2753 mod 3233 = 123"
        ]
      },
      "calculator": {
        "title": "RSA Calculator",
        "prime": "Prime",
        "generateKeys": "Generate Keys",
        "publicKey": "Public Key",
        "privateKey": "Private Key",
        "encrypt": "Encrypt",
        "decrypt": "Decrypt",
        "encrypted": "Encrypted",
        "decrypted": "Decrypted",
        "messageToEncrypt": "Message to Encrypt"
      }
    }
  },
  "graphTheory": {
    "introduction": {
      "title": "Introduction to Graph Theory",
      "graphDefinition": {
        "title": "Definition of a Graph",
        "definition": "A graph is a mathematical structure consisting of two sets:",
        "vertices": "V (vertices): A non-empty set of elements called vertices or nodes.",
        "edges": "E (edges): A set of pairs of vertices, representing connections between them.",
        "formal": "Formally, we write a graph as G = (V, E).",
        "explanation": "The graph above shows a simple undirected graph with 6 vertices and 9 edges.",
        "interactionPrompt": "You can click and drag the vertices to rearrange the graph!"
      },
      "graphDirectedness": {
        "title": "Undirected vs Directed Graphs",
        "definition": "Graphs can be classified as undirected or directed based on the nature of their edges:",
        "undirected": {
          "label": "Undirected Graph",
          "description": "Edges have no direction. The relationship between connected vertices is symmetric."
        },
        "directed": {
          "label": "Directed Graph (Digraph)",
          "description": "Edges have a direction. The relationship between connected vertices can be asymmetric."
        },
        "selectedEdge": "Selected edge: {{edge}}",
        "prompt": "Click on an edge in either graph to see the difference in representation.",
        "interactionPrompt": "Click on edges in both graphs to compare undirected and directed representations!"
      },
      "verticesAndEdges": {
        "title": "Vertices and Edges",
        "description": "A graph consists of two main elements:",
        "vertices": {
          "label": "Vertices (Nodes)",
          "description": "Points or circles in the graph"
        },
        "edges": {
          "label": "Edges",
          "description": "Lines connecting the vertices"
        },
        "explanation": "In the example graphs: The circles are vertices. The lines connecting these circles are edges. In the directed graph (right), edges have arrows indicating direction.",
        "interactionPrompt": "Click on \"Vertices\" or \"Edges\" above to highlight them in both graphs!",
        "undirectedGraph": "Undirected Graph",
        "directedGraph": "Directed Graph"
      },
      "vertexDegree": {
        "title": "Degree of a Vertex",
        "description": "The degree of a vertex is the number of edges connected to it. In other words, it's the number of neighbors a vertex has.",
        "undirectedGraphDescription": "For undirected graphs, it's simply the count of edges connected to the vertex.",
        "directedGraphDescription": "For directed graphs, we distinguish between in-degree (incoming edges) and out-degree (outgoing edges).",
        "undirectedGraph": "Undirected Graph",
        "directedGraph": "Directed Graph",
        "undirectedDegreeExplanation": "In the undirected graph, the degree of vertex {{selectedNode}} is {{undirectedDegree}}.",
        "directedDegreeExplanation": "In the directed graph, vertex {{selectedNode}} has in-degree {{inDegree}} and out-degree {{outDegree}}.",
        "selectVertexPrompt": "Click on a vertex in either graph to see its degree.",
        "interactionPrompt": "Click on different vertices in both graphs to compare degrees in undirected and directed graphs!"
      },
      "pathsAndCycles": {
        "title": "Paths and Cycles in Graphs",
        "description": "In graph theory, paths and cycles are fundamental concepts: A path is a sequence of nodes connected by edges, without repeating any node. A cycle is a path that starts and ends at the same node.",
        "pathExplanation": "This is a path: e → f → g → a → b → c → d. It's a sequence of connected nodes without repetition.",
        "cycleExplanation": "This is a cycle: a → b → c → f → g → a. It starts and ends at the same node.",
        "showPathButton": "Show Path",
        "showCycleButton": "Show Cycle",
        "interactiveDescription": "Create your own graph by clicking to add nodes and connecting them. Then detect cycles in your graph.",
        "resetButton": "Reset Graph",
        "cyclesDetected": "Cycle(s) detected in the graph",
        "interactivePrompt": "Click on the graph area to add nodes. Click on two nodes consecutively to create an edge between them. Use the 'Detect Cycles' button to find cycles in your graph."
      },
      "graphConnectivity": {
        "title": "Graph Connectivity",
        "description": "Graph connectivity refers to whether all nodes in a graph are connected. A graph is connected if there is a path between every pair of nodes.",
        "connectedGraph": "Connected Graph",
        "disconnectedGraph": "Disconnected Graph",
        "connectedExplanation": "In this connected graph, you can reach any node from any other node by following the edges.",
        "disconnectedExplanation": "This disconnected graph has two separate components. You cannot reach nodes C or D from A or B.",
        "additionalInfo": "A connected graph has only one component, while a disconnected graph has two or more components. Components are subgraphs where all nodes are connected to each other, but not to nodes in other components."
      },
      "subgraphs": {
        "title": "Subgraphs",
        "description": "A subgraph is a graph whose set of nodes and edges are subsets of another graph. It's like taking a piece of a larger graph while maintaining the connections between the selected elements.",
        "fullGraphExplanation": "This is the full graph. A subgraph is a subset of nodes and edges from this graph.",
        "triangleExplanation": "This triangle (A-B-C) is a subgraph. It includes some, but not all, of the original graph's nodes and edges.",
        "pathExplanation": "This path (B-C-D-E) is also a subgraph. It's a sequence of connected nodes that's part of the larger graph.",
        "showFullGraph": "Show Full Graph",
        "showTriangle": "Show Triangle Subgraph",
        "showPath": "Show Path Subgraph",
        "resetButton": "გადატვირთვა"
      }
    },
    "differentGraphs": {
      "title": "Different Kind of Graphs",
      "weightedGraphs": {
        "title": "Weighted Graphs",
        "description": "Weighted graphs are graphs in which each edge is assigned a numerical value, called a weight. These weights can represent various real-world quantities such as distance, cost, or capacity. There are two main types of weighted graphs:",
        "undirectedDescription": "Undirected Weighted Graphs: The edges have no direction, and the weight applies in both directions between the connected nodes.",
        "directedDescription": "Directed Weighted Graphs: The edges have a specific direction, and the weight applies only in that direction.",
        "undirectedGraph": "Undirected Weighted Graph",
        "directedGraph": "Directed Weighted Graph",
        "edgeWeightExplanation": "The selected edge {{selectedElement}} has a weight of {{weight}}.",
        "nodeExplanation": "You've selected node {{selectedElement}}. In a weighted graph, the weights are associated with edges, not nodes.",
        "selectElementPrompt": "Click on a node or edge to see more information.",
        "interactionPrompt": "Interact with the graphs above to explore the concept of weighted graphs. Click on edges to see their weights, or on nodes to understand their role in weighted graphs."
      },
      "planarGraphs": {
        "planarTitle": "Planar Graphs",
        "planarDescription": "A planar graph is a type of graph that can be drawn on a flat surface such that no edges cross, except at their vertices. This means the edges only intersect at their endpoints.",
        "planarLabel": "Planar Graph",
        "nonPlanarLabel": "Non-Planar Graph",
        "planarInteractionPrompt": "Adjust the slider to explore how the graph changes with different node counts. Observe the differences between planar and non-planar graphs.",
        "numberOfNodes": "Number of Nodes"
      },
      "bipartiteGraphs": {
        "title": "Bipartite Graphs",
        "description": "A bipartite graph is a graph whose vertices can be divided into two disjoint sets such that every edge connects a vertex in one set to a vertex in the other set. In other words, there are no edges between vertices within the same set.",
        "bipartiteLabel": "Bipartite Graph",
        "examples": {
          "0": "Students and Classes: One set represents students, the other represents classes. Edges show which students are enrolled in which classes.",
          "1": "Actors and Movies: One set for actors, another for movies. Edges show which actors appeared in which movies.",
          "2": "Authors and Books: One set for authors, another for books. Edges represent which authors wrote which books."
        },
        "applicationNote": "These examples demonstrate how bipartite graphs can represent relationships between two different types of entities, making them powerful tools for analyzing and visualizing various systems and networks.",
        "nonBipartiteLabel": "Non-Bipartite Graph",
        "interactionPrompt": "Use the slider below to change the number of nodes in both graphs. Notice how the bipartite graph always maintains two distinct sets of nodes, while the non-bipartite graph allows connections within the same set.",
        "numberOfNodes": "Number of Nodes"
      },
      "regularGraphs": {
        "title": "Regular Graphs",
        "description": "A regular graph is a graph where each vertex has the same number of neighbors; in other words, every vertex has the same degree. Regular graphs are fundamental in graph theory and have various applications in network design, chemistry, and social network analysis.",
        "numberOfVertices": "Number of Vertices",
        "degree": "Degree",
        "oddEvenDescription": "The number of vertices and the degree of a regular graph are closely related. For a regular graph to exist, the product of the number of vertices and the degree must be even. This is because each edge contributes to the degree of two vertices. As a result, regular graphs with an odd number of vertices must have an even degree, while graphs with an even number of vertices can have either an odd or even degree. Explore these relationships by adjusting the number of vertices and degree below.",
        "interactionPrompt": "Use the controls below to adjust the number of vertices and the degree. Observe how the regular graph changes and which combinations are possible or impossible."
      },
      "completeGraphs": {
        "title": "Complete Graphs",
        "description": "A complete graph is a graph in which every pair of distinct vertices is connected by a unique edge. In a complete graph with n vertices, each vertex has a degree of n-1, and the total number of edges is n(n-1)/2.",
        "interactionPrompt": "Use the controls below to adjust the number of vertices. Observe how the number of edges and the degree of each vertex change as you modify the graph.",
        "numberOfVertices": "Number of Vertices",
        "edgeCount": "Number of Edges: {{num}}",
        "degreeProp": "Degree of each vertex: {{degree}}"
      },
      "trees": {
        "title": "Trees",
        "description": "In graph theory, a tree is a connected, acyclic graph. Trees are used to represent hierarchies and enable efficient algorithms.",
        "tree1": "Binary Tree",
        "tree1Explanation": "A binary tree where each node has at most two children. Commonly used for efficient searching and sorting algorithms.",
        "tree2": "General Tree",
        "tree2Explanation": "A tree where nodes can have any number of children. Useful for representing complex hierarchies like file systems or organizational charts.",
        "interactionPrompt": "Interact with the trees!"
      }
    },
    "graphTraversals": {
      "title": "Graph Traversals",
      "bfs": {
        "title": "Breadth-First Search (BFS)",
        "explanation": "Breadth-First Search (BFS) is like exploring a city neighborhood by neighborhood. Imagine you're standing at your home (the starting node) and want to find a specific place. Instead of going down one long street at a time, you first visit all the places on your block. Then, you move to all the places one block away, then two blocks away, and so on. This way, you're sure to find the closest location first. In graph terms, BFS starts at a chosen node and explores all its neighbors before moving to the next level. It uses a queue (like a waiting line) to keep track of which nodes to visit next. This method ensures that nodes are visited in order of their distance from the start, making BFS ideal for finding the shortest path between two points in an unweighted graph.\n\nBFS is widely used in applications like social network friend suggestions, GPS navigation for finding nearby places, and even in puzzle-solving algorithms!",
        "demoDescription": "Watch the animation below to see how BFS explores a graph level by level:",
        "interactionDescription": "Now, try creating your own graph and run BFS to see how it works on different structures:",
        "interactionPrompt": "Click empty space to add nodes. Click two nodes in succession to create an edge. Click a node to set it as the start node (highlighted in green). Press play to begin BFS.",
        "unvisitedNode": "Unvisited Node",
        "visitedNode": "Visited Node",
        "currentNode": "Current Node",
        "queuedNode": "Queued Node",
        "traversedEdge": "Traversed Edge"
      },
      "dfs": {
        "title": "Depth-First Search (DFS)",
        "explanation": "Depth-First Search (DFS) is like exploring a maze by always choosing the deepest unexplored path. Imagine you're in a cave system: you keep going deeper into unexplored tunnels until you hit a dead end, then you backtrack to the last junction with an unexplored path. This method ensures you explore every possible path.",
        "demoDescription": "Watch the animation below to see how DFS explores a graph, always choosing the leftmost unexplored path first:",
        "interactionDescription": "Now, try creating your own graph and run DFS to see how it works on different structures:",
        "interactionPrompt": "Click to add nodes. Click two nodes to create an edge. Click a node to set as start. Press play to begin DFS.",
        "unvisitedNode": "Unvisited Node",
        "visitedNode": "Visited Node",
        "currentNode": "Current Node",
        "stackNode": "Node in Stack",
        "forwardEdge": "Explored Edge",
        "runDFS": "Run DFS",
        "resetGraph": "Reset Graph"
      }
    },
    "graphAlgorithms": {
      "title": "Graph Algorithms",
      "graphIsomorphism": {
        "title": "Graph Isomorphism",
        "introduction": "Graph isomorphism is a fundamental concept in graph theory that helps us understand when two graphs have the same structure, regardless of how they're drawn or labeled.",
        "definitionTitle": "What is Graph Isomorphism?",
        "definition": "Two graphs G and H are considered isomorphic if there exists a bijective function f from the vertices of G to the vertices of H such that any two vertices u and v are adjacent in G if and only if f(u) and f(v) are adjacent in H. In simpler terms, isomorphic graphs have the same structure and can be transformed into each other by relabeling the vertices.",
        "determinationTitle": "How to Determine Isomorphism",
        "determination": "Determining whether two graphs are isomorphic can be challenging. Here are some key steps:\n\n1. Check if the graphs have the same number of vertices and edges.\n2. Compare the degree sequences of both graphs.\n3. Look for cycles of the same length in both graphs.\n4. Check for the presence of similar subgraphs.\n\nHowever, these are necessary but not sufficient conditions. The only way to prove isomorphism is to find a bijective mapping between the vertices that preserves adjacency.",
        "exampleDescription": "Below are two isomorphic graphs. Although they look different, they have the same structure.",
        "isomorphicResult": "The graphs are isomorphic! They have the same structure despite potentially different layouts or labels.",
        "nonIsomorphicResult": "The graphs are not isomorphic. They have different structures.",
        "interactiveDescription": "Click on the graph area to add nodes. Click on two nodes consecutively to create an edge between them. Use the buttons below to check for isomorphism or reset the graphs."
      },
      "spanningTree": {
        "title": "Graph Spanning Trees",
        "introduction": "A spanning tree is a fundamental concept in graph theory, with important applications in network design, circuit analysis, and algorithms. This interactive demonstration will help you understand how spanning trees work and how they're constructed.",
        "definitionTitle": "What is a Spanning Tree?",
        "definition": "A spanning tree of an undirected graph is a subgraph that includes all the vertices of the original graph, with the minimum possible number of edges to form a tree (a connected graph without cycles). In other words, a spanning tree reaches all nodes while avoiding any loops.",
        "algorithmTitle": "How to Find a Spanning Tree",
        "algorithm": "There are several algorithms to find a spanning tree. A common approach is to use Breadth-First Search (BFS):\n1. Start from any node in the graph.\n2. Explore all unvisited neighboring nodes.\n3. For each unvisited neighbor, add the edge connecting it to the current node to the spanning tree.\n4. Repeat steps 2-3 until all nodes are visited.\nThis process ensures we reach all nodes with the minimum number of edges, creating a valid spanning tree.",
        "exampleDescription": "Here's an example graph with a highlighted spanning tree. The teal nodes and orange edges represent the spanning tree.",
        "exampleExplanation": "In this example, we have a graph with 8 nodes (A through H) and 12 edges. The highlighted spanning tree contains 7 edges, which is the minimum number needed to connect all 8 nodes without forming any cycles. Notice how the spanning tree reaches every node in the graph, but some edges from the original graph are not included. This demonstrates how a spanning tree maintains connectivity while minimizing the number of edges used.",
        "interactiveDescription": "Now it's your turn! Click on the graph area to add nodes. Click on two nodes consecutively to create an edge between them. Use the 'Play' button to find a spanning tree, and the 'Delete' button to reset the graph.",
        "spanningTreeFound": "Spanning Tree Found!",
        "spanningTreeFoundDescription": "A spanning tree has been successfully found and highlighted in the graph.",
        "spanningTreeNotFound": "Spanning Tree Not Found",
        "spanningTreeNotFoundDescription": "A spanning tree could not be found. This happens when the graph is not connected (i.e., there are isolated nodes or subgraphs)."
      },
      "graphColoring": {
        "title": "Graph Coloring",
        "introduction": "Graph coloring is a fundamental concept in graph theory with various practical applications.",
        "definitionTitle": "Definition",
        "definition": "Graph coloring is the assignment of colors to the vertices of a graph such that no two adjacent vertices share the same color.",
        "algorithmTitle": "Algorithm",
        "algorithm": "A simple greedy algorithm for graph coloring works by iterating through the vertices and assigning the first available color that hasn't been used by any adjacent vertices.",
        "exampleDescription": "Here's a simple graph demonstrating the coloring algorithm:",
        "exampleExplanation": "Notice how no two connected nodes share the same color.",
        "interactiveDescription": "Create your own graph by clicking on the canvas to add nodes. Click on two nodes to connect them with an edge. Then use the buttons below to color the graph or reset it.",
        "resultTitle": "Coloring Result",
        "resultDescription": "The graph has been colored successfully. Observe how the algorithm minimized the number of colors used while ensuring no adjacent nodes share the same color.",
        "usedColors": "Number of colors used: {{count}}"
      }
    }
  },
  "graphProblems": {
    "title": "Problems for Graph Theory"
  }
}
