{
  "title": "Math for Computer Science",
  "courses": "Courses",
  "signIn": "Sign In",
  "signOut": "Sign Out",
  "register": "Register",
  "introduction_to_logical_operators_title": "Introduction to Logical Operators",
  "calculate": "Calculate",
  "binarySystemTitle": "Binary System",
  "logicalOperandsTitle": "Logical Operands",
  "graphTheoryTitle": "Theory of Graphs",
  "numberTheoryTitle": "Theory of Numbers",
  "introduction": "Introduction",
  "lcm-gcd": "LCM and GCD",
  "rsa-algorithm": "RSA Algorithm",
  "modular-arithmetic": "Modular Arithmetic",
  "quizResults": "Quiz Results",
  "question": "Question",
  "yourAnswer": "Your Answer",
  "correctAnswer": "Correct Answer",
  "totalScore": "Total Score",
  "tryAgain": "Try Again",
  "correct": "Correct",
  "incorrect": "Incorrect",
  "decimalValue": "Decimal Value",
  "converting": "Converting",
  "binaryRepresentation": "Binary Representation",
  "binaryArithmetic": "Binary Arithmetic",
  "clickToExplore": "Click to explore this course",
  "welcome": "Welcome",
  "complete": "Complete",
  "result": "Result",
  "wantToTakeQuiz": "Want to take a quiz?",
  "wantToSolveProblems": "Want to solve problems?",
  "viewResults": "View Results",
  "red": "Red",
  "green": "Green",
  "blue": "Blue",
  "binaryColorMixer": "Binary Color Mixer",
  "hours": "Hours",
  "minutes": "Minutes",
  "seconds": "Seconds",
  "currentTime": "Current Time",
  "example": "Example",
  "binaryConversionGame": "Binary Conversion Game",
  "startGame": "Start Game",
  "convertToDecimal": "Convert to Decimal",
  "convertToBinary": "Convert to Binary",
  "score": "Score",
  "timeLeft": "Time Left",
  "secondsShort": "s",
  "submit": "Submit",
  "binaryNumber": "Binary Number",
  "enterOnesAndZeros": "Enter 0s and 1s",
  "chooseCourse": "Select the course you wish to enroll in",
  "completed": "COMPLETED",
  "problemCompletion": "Problem Completion",
  "easy": "Easy",
  "medium": "Medium",
  "hard": "Hard",
  "binaryProblems": "Binary System Problems",
  "numberTheoryProblems": "Number Theory Problems",
  "problems": {
    "selectProblem": "Select a Problem",
    "description": "Description:",
    "difficulty": "Difficulty:",
    "task": "Task:",
    "inputFormat": "Input Format:",
    "outputFormat": "Output Format:",
    "example": "Example:",
    "note": "Note:",
    "language": "Language",
    "chooseLanguage": "Choose Language",
    "runCode": "Run Code",
    "running": "Running...",
    "output": "Output:",
    "testCase": "Test Case",
    "testCaseSuccessful": "Successful",
    "testCaseFailed": "Failed",
    "expectedResult": "Expected",
    "gotResult": "Got",
    "codeAndTestsRunning": "Running code and tests..."
  },
  "binarySystem": {
    "introduction": {
      "title": "Introduction to the Binary System",
      "welcome": "Welcome to the world of the Binary System! In our daily lives, we're used to working with the decimal system, which uses ten digits (0-9). But did you know that at the heart of every computer lies a much simpler system using only two digits: 0 and 1? This is the Binary System, and it's the foundation of all digital computing.",
      "whatIs": {
        "title": "What is the Binary System?",
        "description": "The Binary System, also known as base-2 number system, is a method of mathematical expression which uses only two symbols: 0 and 1. Each of these digits is called a 'bit' (short for 'binary digit')."
      },
      "whyImportant": {
        "title": "Why is it important?",
        "description": "The Binary System is crucial in computing for several reasons:",
        "points": [
          "Simplicity: With only two states, binary is perfect for representing on/off, true/false, or yes/no situations.",
          "Electronic Implementation: It's easy to represent binary digits using electrical signals - on for 1, off for 0.",
          "Error Detection: Binary makes it easier to detect and correct errors in data transmission.",
          "Foundation of Computing: All data in computers - text, images, videos, and even the instructions that tell the computer what to do - are ultimately stored and processed as binary."
        ]
      },
      "realLifeExamples": {
        "title": "Real-Life Examples of Binary System",
        "description": "The binary system isn't just a theoretical concept - it's all around us in our daily lives! Here are some examples:",
        "points": [
          "Digital Photography: When you take a photo with a digital camera or smartphone, the image is stored as a series of binary numbers.",
          "Music Streaming: When you listen to music on Spotify or Apple Music, you're actually hearing binary data converted into sound waves.",
          "Morse Code: While not strictly binary, Morse code is a close analog, using dots and dashes to encode letters and numbers.",
          "Computer Screens: Each pixel on your computer or phone screen is controlled by binary data, creating the full spectrum of colors you see."
        ]
      },
      "conclusion": "As you delve deeper into computer science, you'll find that understanding binary is crucial for topics like digital logic, computer architecture, and data representation. These real-world applications show how this simple system of 1s and 0s underpins much of our modern, digital world. So, let's embark on this binary adventure together!"
    },
    "representation": {
      "title": "Binary Number Representation",
      "description": "Binary is the language of computers, using only two digits: 0 and 1. Let's explore how this simple system can represent complex information.",
      "placeValue": {
        "title": "Place Value in Binary",
        "description": "In binary, each position represents a power of 2, similar to how decimal uses powers of 10.",
        "table": {
          "position": "Position",
          "value": "Value"
        }
      },
      "patterns": {
        "title": "Binary Patterns and Properties",
        "description": "Recognizing patterns in binary can help in understanding and working with them:",
        "examples": [
          "All 1s: Represents 2^n - 1 (e.g., 1111 = 15)",
          "Leading 1 followed by 0s: Powers of 2 (e.g., 1000 = 8)"
        ]
      },
      "binaryInColors": {
        "title": "Binary in Colors",
        "description": "RGB colors use binary to represent millions of colors. Experiment with the sliders to see how binary creates colors:"
      },
      "binaryClock": {
        "title": "Binary Clock",
        "description": "A binary clock uses the binary number system to display the time. Can you read the time below?"
      }
    },
    "conversion": {
      "title": "Binary-Decimal Conversion",
      "description": "Converting between binary and decimal is fundamental in computer science. Let's explore different methods and practice conversion skills.",
      "decimalToBinary": {
        "title": "Decimal to Binary Conversion",
        "description": "To convert decimal to binary, we can use the division by 2 method:",
        "example": "Convert 25 to binary\n25 ÷ 2 = 12 remainder 1\n12 ÷ 2 = 6 remainder 0\n6 ÷ 2 = 3 remainder 0\n3 ÷ 2 = 1 remainder 1\n1 ÷ 2 = 0 remainder 1\nReading remainders from bottom to top: 25 = 11001"
      },
      "binaryToDecimal": {
        "title": "Binary to Decimal Conversion",
        "description": "To convert binary to decimal, we multiply each digit by its place value and sum the results:",
        "example": "Convert 11001 to decimal\n1 × 2^4 + 1 × 2^3 + 0 × 2^2 + 0 × 2^1 + 1 × 2^0\n= 16 + 8 + 0 + 0 + 1\n= 25"
      },
      "shortcutMethods": {
        "title": "Shortcut Methods",
        "description": "Some quick tricks for binary-decimal conversion:",
        "methods": [
          "For powers of 2, the binary form is 1 followed by that many zeros",
          "To double a binary number, add a 0 to the right",
          "To halve an even binary number, remove the rightmost 0"
        ]
      },
      "conversionTable": {
        "title": "Binary-Decimal Conversion Table",
        "description": "This table shows binary equivalents for decimal numbers 0-15:",
        "decimal": "Decimal",
        "binary": "Binary"
      },
      "converter": {
        "title": "Interactive Binary Converter",
        "description": "Use this tool to convert between binary and decimal."
      },
      "game": {
        "title": "Binary Conversion Game",
        "description": "Test your conversion skills with this fun game! Convert as many numbers as you can in 60 seconds:"
      },
      "calculator": {
        "binary": "Binary",
        "decimal": "Decimal",
        "enterBinaryNumber": "Enter binary number",
        "enterDecimalNumber": "Enter decimal number"
      },
      "flowchart": {
        "decimalToBinaryTitle": "Decimal to Binary Conversion",
        "binaryToDecimalTitle": "Binary to Decimal Conversion",
        "decimalToBinary": [
          "Start with decimal number",
          "↓",
          "Divide by 2",
          "↓",
          "Note remainder (0 or 1)",
          "↓",
          "Continue dividing quotient by 2",
          "↓",
          "Stop when quotient becomes 0",
          "↓",
          "Read remainders from bottom to top"
        ],
        "binaryToDecimal": [
          "Start with binary number",
          "↓",
          "Multiply each digit by power of 2",
          "↓",
          "Sum all products",
          "↓",
          "Result is decimal number"
        ]
      }
    },
    "arithmetic": {
      "title": "Binary Arithmetic",
      "description": "Binary arithmetic involves performing mathematical operations using only two digits: 0 and 1.",
      "addition": {
        "title": "Binary Addition",
        "description": "Binary addition is similar to decimal addition, but with only two digits. We start from the rightmost column and carry over when the sum exceeds 1.",
        "example": "  1 1 0 1\n+ 1 0 1 1\n  -------\n1 1 0 0 0"
      },
      "subtraction": {
        "title": "Binary Subtraction",
        "description": "Binary subtraction follows similar rules to decimal subtraction. When we need to borrow, we borrow from the next column to the left.",
        "example": "  1 1 0 1\n- 1 0 1 1\n  -------\n  0 0 1 0"
      },
      "multiplication": {
        "title": "Binary Multiplication",
        "description": "Binary multiplication is a series of additions. We multiply each digit of one number by the other number, shifting left each time.",
        "example": "        1 1 0 1\n      ×   1 0 1\n        -------\n        1 1 0 1\n      0 0 0 0\n    1 1 0 1\n        -------\n  1 0 0 0 0 0 1"
      },
      "division": {
        "title": "Binary Division",
        "description": "Binary division is similar to long division in decimal. We perform repeated subtraction and bring down digits as needed.",
        "example": "1 1 0 1 | 1 0\n1 0     -------\n---     1 1 0  (r 1)\n  1 0\n  1 0\n  ---\n    0 1\n      0\n    ---\n      1"
      },
      "twoComplement": {
        "title": "Two's Complement",
        "description": "Two's complement is a way to represent signed integers in binary. It's widely used in computer systems for subtraction and representing negative numbers.",
        "steps": [
          "Invert all the bits (change 0 to 1 and 1 to 0)",
          "Add 1 to the result"
        ],
        "example": "-5 in 8-bit two's complement\n1. Positive 5:  0000 0101\n2. Invert bits: 1111 1010\n3. Add 1:      1111 1011\nSo, -5 in two's complement is 1111 1011"
      },
      "applications": {
        "title": "Applications of Binary Arithmetic",
        "description": "Binary arithmetic is fundamental to how computers process information. Here are some real-world applications:",
        "examples": [
          "Digital Signal Processing: Used in audio and video compression",
          "Cryptography: For encoding and decoding secure messages",
          "Error Correction: In data transmission and storage",
          "Computer Graphics: For rendering images and animations",
          "Artificial Intelligence: In neural network computations"
        ]
      },
      "calculator": {
        "title": "Binary Calculator",
        "description": "Practice binary arithmetic operations with this interactive calculator:"
      }
    }
  },
  "logicalOperands": {
    "title": "Logical Operands",
    "introduction": {
      "title": "Introduction",
      "description": "Logical operators are a fundamental topic in discrete mathematics and computer science. Their use allows us to build complex conditions and determine decisions in ongoing processes within a program.",
      "moduleExploration": {
        "header": "In this course, you will explore the following topics:",
        "items": [
          "Basic logical operators",
          "Advanced logical operators",
          "Truth tables"
        ]
      },
      "understandingImportance": {
        "header": "The Importance of Logical Operators",
        "items": [
          "They are essential for defining conditions and controlling the flow of a program.",
          "They form the basis for designing computer systems.",
          "They are widely used for complex queries in databases.",
          "They play a significant role in artificial intelligence systems, especially in decision-making algorithms."
        ]
      },
      "realLifeExamples": {
        "header": "Logical Operators in Everyday Life",
        "description": "The concept of logical operators is not just a computer science notion. It also appears in our everyday decisions. Let’s consider a simple example with light switches:",
        "lightSwitchExample": {
          "title": "Light Switch Example",
          "description": "Imagine you have a room with two switches. Each switch can be either on or off. Let’s introduce two logical operators: AND and OR. We’ll examine them with examples.",
          "andOperatorName": "AND",
          "andOperator": " - The light will be on only when both switches are on.",
          "orOperatorName": "OR",
          "orOperator": " - The light will be on if at least one of the switches is on."
        }
      },
      "progressNote": "As you progress through this course, you will gain a solid understanding of logical operators, preparing you for more advanced topics in computer science and discrete mathematics."
    },
    "basicOperators": {
      "title": "Basic Logical Operators",
      "introduction": "Welcome to the world of logical operators! These powerful tools are the building blocks of decision-making in programming and everyday life. Just like traffic lights guide cars on the road, logical operators guide the flow of our programs. They help us make choices based on multiple conditions, allowing our code to think and react. Let's see how they shape the digital world around us!",
      "interactionPrompt": "Let's get hands-on! Click the bits below to flip between 0 (false) and 1 (true). Watch how each operator responds to your choices!",
      "and": {
        "title": "AND: The Perfectionist",
        "description": "The AND operator is like a strict teacher – it only gives a passing grade (returns true or 1) when all conditions are met. If any condition fails, the result is a fail (false or 0).",
        "explanation": "Imagine you're planning the perfect picnic. You'll only go if it's sunny AND you have free time AND you've packed your basket. The AND operator works the same way in programming. It checks if all conditions are true, just like you checking off all items on your picnic checklist. It's perfect for situations where you need everything to align just right!",
        "symbol": "&&"
      },
      "or": {
        "title": "OR: The Flexible Friend",
        "description": "The OR operator is like a lenient parent – if any of the conditions are met (true or 1), it gives a thumbs up. It only returns false (0) when all conditions fail.",
        "explanation": "Think of OR as your weekend plans. You'll be happy if you get to watch a movie OR hang out with friends OR read a good book. Any of these make for a good time! In programming, OR helps us create flexible conditions. It's great when you have multiple acceptable options and any one of them is enough to proceed.",
        "symbol": "||"
      },
      "not": {
        "title": "NOT: The Rebel",
        "description": "The NOT operator is the rebel of the bunch – it always does the opposite. It turns true into false, and false into true.",
        "explanation": "Imagine a mischievous sibling who always does the opposite of what you say. If you say 'don't touch that,' they'll touch it. That's exactly how NOT works! It's incredibly useful when you want to check if something is NOT true. For example, checking if a user is NOT logged in to show them a login prompt. NOT helps us flip our logic on its head when we need to!",
        "symbol": "!"
      },
      "truthTables": {
        "title": "Truth Tables: The Logic Roadmap",
        "tableHeaderA": "Condition A",
        "tableHeaderB": "Condition B",
        "tableHeaderResult": "Final Outcome"
      },
      "logicalOperatorGame": {
        "title": "Logical Operator Game",
        "introduction": "Test your skills with AND, OR, and NOT operators. How many can you solve in 30 seconds?",
        "time": "Time",
        "score": "Score",
        "gameOver": "Game Over!",
        "finalScore": "Final Score",
        "startGame": "Start Game",
        "playAgain": "Play Again",
        "true": "True",
        "false": "False"
      }
    },
    "advancedOperators": {
      "title": "Advanced Logical Operators",
      "introduction": "Welcome to the world of advanced logical operators! These powerful tools build upon the basic operators to create more complex decision-making structures in programming. Like master chefs combining ingredients, these operators mix basic logic to create sophisticated outcomes. Let's explore how they add depth to our logical toolbox!",
      "interactionPrompt": "Let's dive in! Click the bits below to toggle between 0 (false) and 1 (true). Observe how each advanced operator processes your inputs!",
      "nand": {
        "title": "NAND: The Universal Negator",
        "description": "The NAND operator is like a contrarian committee – it only returns false when all inputs are true. In all other cases, it returns true.",
        "explanation": "Imagine a group of friends deciding on a movie. With NAND, you'll only stay home if everyone agrees on the same movie. Any disagreement, and you're going out! In circuits, NAND is special because it can be used to create all other logical operations, making it a versatile building block.",
        "symbol": "⊼"
      },
      "nor": {
        "title": "NOR: The Universal Pessimist",
        "description": "The NOR operator is like an extreme critic – it only returns true when all inputs are false. If any input is true, it returns false.",
        "explanation": "Think of NOR as a picky eater at a buffet. They'll only be satisfied (return true) if none of the dishes appeal to them. If even one dish looks good, they're unsatisfied. In digital logic, NOR is powerful because, like NAND, it can be used to construct all other logical operations.",
        "symbol": "⊽"
      },
      "xor": {
        "title": "XOR: The Exclusive Decider",
        "description": "XOR is like a picky choice-maker – it returns true only when inputs differ, and false when they're the same.",
        "explanation": "Imagine you're packing for a trip and can only bring one type of shoes: casual OR formal, but not both and not neither. XOR ensures you make exactly one choice. In programming, XOR is great for toggle situations or checking for differences between two conditions.",
        "symbol": "⊕"
      },
      "truthTables": {
        "title": "Truth Tables: The Advanced Logic Map",
        "tableHeaderA": "Input A",
        "tableHeaderB": "Input B",
        "tableHeaderResult": "Result"
      },
      "advancedLogicalOperatorGame": {
        "title": "Advanced Logical Operator Challenge",
        "introduction": "Test your mastery of NAND, NOR, and XOR operators. How many puzzles can you solve in 30 seconds?",
        "time": "Time",
        "score": "Score",
        "gameOver": "Challenge Complete!",
        "finalScore": "Final Score",
        "startGame": "Begin Challenge",
        "playAgain": "Try Again",
        "true": "True",
        "false": "False"
      }
    },
    "problems": {
      "title": "Problems for Logical Operators"
    }
  },
  "numberTheory": {
    "introduction": {
      "title": "Introduction to the Theory of Numbers",
      "description": "The Theory of Numbers, also known as Number Theory, is a branch of pure mathematics devoted primarily to the study of the integers and integer-valued functions. It is one of the oldest and most fundamental areas of mathematics, with a rich history dating back to ancient civilizations.",
      "keyConcepts": {
        "title": "Key Concepts in Number Theory:",
        "list": [
          "Prime Numbers: Numbers greater than 1 that have no positive divisors other than 1 and themselves.",
          "Divisibility: The study of when one integer is divisible by another.",
          "Greatest Common Divisor (GCD): The largest positive integer that divides each of the numbers without a remainder.",
          "Least Common Multiple (LCM): The smallest positive integer that is divisible by each of the numbers.",
          "Modular Arithmetic: Arithmetic that deals with the remainders after division.",
          "Diophantine Equations: Polynomial equations where only integer solutions are sought."
        ]
      },
      "applications": {
        "title": "Applications of Number Theory:",
        "list": [
          "Cryptography: Many encryption methods, including RSA, are based on number theory principles.",
          "Computer Science: Algorithms, data structures, and error-correcting codes often rely on number theory concepts.",
          "Engineering: Applications in signal processing, control theory, and other engineering fields."
        ]
      }
    },
    "lcmAndGcd": {
      "title": "Least Common Multiple (LCM) and Greatest Common Divisor (GCD)",
      "whatAre": {
        "title": "What are LCM and GCD?",
        "lcm": {
          "title": "Least Common Multiple (LCM)",
          "description": "The LCM of two or more integers is the smallest positive integer that is divisible by each of the integers. For example, the LCM of 4 and 6 is 12."
        },
        "gcd": {
          "title": "Greatest Common Divisor (GCD)",
          "description": "The GCD of two or more integers is the largest positive integer that divides each of the integers without a remainder. For example, the GCD of 8 and 12 is 4."
        }
      },
      "importance": {
        "title": "Why are LCM and GCD important?",
        "list": [
          "LCM is used in many areas of mathematics, including algebra, and number theory.",
          "GCD is fundamental in simplifying fractions, solving Diophantine equations, and in various algorithms in computer science.",
          "Both LCM and GCD are crucial in cryptography, particularly in the RSA algorithm.",
          "In computer programming, LCM and GCD are used in various algorithms and data structures."
        ]
      },
      "calculation": {
        "title": "How to Calculate LCM and GCD",
        "gcd": {
          "title": "Calculating GCD",
          "description": "The most efficient method to calculate GCD is the Euclidean algorithm:",
          "steps": [
            "Divide the larger number by the smaller one.",
            "Replace the larger number with the smaller number and the smaller number with the remainder from step 1.",
            "Repeat until the remainder is zero. The last non-zero remainder is the GCD."
          ]
        },
        "lcm": {
          "title": "Calculating LCM",
          "description": "LCM can be calculated using the formula:",
          "formula": "LCM(a, b) = |a * b| / GCD(a, b)",
          "note": "Where |a * b| denotes the absolute value of a * b."
        }
      },
      "examples": {
        "title": "Examples",
        "gcd": {
          "title": "GCD Example: Calculate GCD(48, 18)",
          "steps": [
            "48 ÷ 18 = 2 remainder 12",
            "18 ÷ 12 = 1 remainder 6",
            "12 ÷ 6 = 2 remainder 0",
            "The last non-zero remainder is 6, so GCD(48, 18) = 6"
          ]
        },
        "lcm": {
          "title": "LCM Example: Calculate LCM(12, 18)",
          "steps": [
            "First, calculate GCD(12, 18) = 6",
            "Then, LCM(12, 18) = |12 * 18| / 6 = 216 / 6 = 36"
          ]
        }
      },
      "calculator": {
        "enterFirstNumber": "Enter first number",
        "enterSecondNumber": "Enter second number",
        "lcm": "LCM",
        "gcd": "GCD"
      }
    },
    "modularArithmetic": {
      "title": "Modular Arithmetic",
      "description": "Modular arithmetic is a system of arithmetic for integers, where numbers 'wrap around' upon reaching a certain value—the modulus. It has important applications in computer science, cryptography, and everyday life.",
      "basics": {
        "title": "Basics of Modular Arithmetic",
        "description": "In modular arithmetic, we consider two numbers to be equivalent if they leave the same remainder when divided by the modulus. We write a ≡ b (mod m) to denote that a and b are congruent modulo m.",
        "example": "For example, 38 ≡ 14 (mod 12) because both 38 and 14 leave a remainder of 2 when divided by 12."
      },
      "operations": {
        "title": "Operations in Modular Arithmetic",
        "description": "Modular arithmetic includes operations similar to standard arithmetic, but with results 'wrapped' to the modulus:",
        "list": [
          "Addition: (a + b) mod m",
          "Subtraction: (a - b) mod m",
          "Multiplication: (a * b) mod m",
          "Exponentiation: (a^b) mod m"
        ],
        "example": "For example, in mod 7: 5 + 4 ≡ 2 (mod 7), because 9 ≡ 2 (mod 7)"
      },
      "properties": {
        "title": "Properties of Modular Arithmetic",
        "description": "Modular arithmetic has several important properties:",
        "list": [
          "Closure: The result of any operation is always within the set of residues modulo m",
          "Associativity: (a + b) + c ≡ a + (b + c) (mod m)",
          "Commutativity: a + b ≡ b + a (mod m)",
          "Distributivity: a * (b + c) ≡ (a * b + a * c) (mod m)"
        ]
      },
      "applications": {
        "title": "Applications of Modular Arithmetic",
        "description": "Modular arithmetic has numerous practical applications:",
        "list": [
          "Cryptography: RSA encryption uses modular exponentiation",
          "Hash functions: Used in digital signatures and blockchain technology",
          "Computer science: Handling cyclic data structures and preventing integer overflow",
          "Clock arithmetic: Representing time in a 12-hour or 24-hour format"
        ]
      },
      "realLifeExamples": {
        "title": "Real-Life Examples of Modular Arithmetic",
        "examples": [
          "Clock arithmetic: When it's 10 o'clock and 5 hours pass, it becomes 3 o'clock (10 + 5 ≡ 3 mod 12).",
          "Day of the week: If today is Tuesday (day 2) and 10 days pass, it will be Friday (2 + 10 ≡ 5 mod 7).",
          "Rotating shifts: In a factory with 3 shifts, after 100 days, the shift will be the same as on day 1 (100 ≡ 1 mod 3)."
        ]
      },
      "calculator": {
        "title": "Modular Arithmetic Calculator",
        "description": "Use this calculator to perform modular arithmetic operations. Enter two numbers, choose an operation, and specify the modulus to see the result.",
        "result": "Result: {{a}} {{operation}} {{b}} ≡ {{result}} (mod {{m}})"
      }
    },
    "rsaAlgorithm": {
      "title": "RSA Algorithm",
      "whatIsRSA": {
        "title": "What is RSA?",
        "description1": "RSA (Rivest-Shamir-Adleman) is a public-key cryptosystem that is widely used for secure data transmission. It is an asymmetric cryptographic algorithm, meaning it uses two different keys: a public key for encryption and a private key for decryption.",
        "description2": "RSA was first described in 1977 by Ron Rivest, Adi Shamir, and Leonard Adleman at MIT. The letters RSA are the initials of their surnames. It was one of the first practical public-key cryptosystems and is still widely used for secure data transmission."
      },
      "importance": {
        "title": "Importance of RSA",
        "list": [
          "Security: RSA's security is based on the practical difficulty of factoring the product of two large prime numbers, known as the factoring problem.",
          "Digital Signatures: RSA can be used to create digital signatures, ensuring the authenticity and integrity of digital messages or documents.",
          "Key Exchange: It enables secure exchange of keys over insecure channels, which is crucial for establishing secure communication.",
          "Widespread Use: RSA is used in many protocols, including SSL/TLS, which is used to secure internet communications."
        ]
      },
      "howItWorks": {
        "title": "How RSA Works: Detailed Steps",
        "keyGeneration": {
          "title": "1. Key Generation:",
          "steps": [
            "Choose two distinct large prime numbers p and q.",
            "Compute n = p * q. This n is called the modulus for both the public and private keys.",
            "Compute φ(n) = (p-1) * (q-1). This is Euler's totient function.",
            "Choose an integer e such that 1 < e < φ(n) and gcd(e, φ(n)) = 1. This e is the public exponent.",
            "Compute d as the modular multiplicative inverse of e (mod φ(n)). This d is the private exponent."
          ]
        },
        "keyDistribution": {
          "title": "2. Key Distribution:",
          "steps": [
            "The public key is (e, n). This can be known to everyone and is used for encryption.",
            "The private key is (d, n). This must be kept secret and is used for decryption."
          ]
        },
        "encryption": {
          "title": "3. Encryption:",
          "steps": [
            "Convert the message into a number m, where 0 ≤ m < n.",
            "Compute the ciphertext c = m^e mod n."
          ]
        },
        "decryption": {
          "title": "4. Decryption:",
          "steps": [
            "Use the private key (d, n) to compute m = c^d mod n.",
            "Convert m back to the original message."
          ]
        }
      },
      "mathematicalFoundation": {
        "title": "Mathematical Foundation",
        "description": "The security of RSA relies on two mathematical facts:",
        "fact1": "1. Modular Exponentiation: It's computationally easy to calculate n = p * q and c = m^e mod n.",
        "fact2": "2. Prime Factorization: It's computationally difficult to determine p and q from n, especially when p and q are large primes.",
        "additional": "The algorithm also relies on Euler's theorem and the properties of modular arithmetic to ensure that encryption and decryption are inverse operations."
      },
      "securityConsiderations": {
        "title": "Security Considerations",
        "list": [
          "Key Size: The security of RSA depends on the size of n. As of 2021, a key size of 2048 bits is considered secure for most applications.",
          "Prime Number Generation: The prime numbers p and q must be generated randomly and kept secret.",
          "Padding: In practice, RSA is often used with padding schemes like OAEP to enhance security.",
          "Side-Channel Attacks: Implementations must be careful to avoid leaking information through timing or power consumption."
        ]
      },
      "practicalExample": {
        "title": "Practical Example",
        "description": "Let's walk through a simple example with small numbers (note: in practice, much larger numbers are used):",
        "steps": [
          "Choose p = 61 and q = 53",
          "Calculate n = 61 * 53 = 3233",
          "Calculate φ(n) = (61-1) * (53-1) = 3120",
          "Choose e = 17 (coprime with 3120)",
          "Find d such that (d * 17) mod 3120 = 1. d = 2753",
          "Public key is (17, 3233), Private key is (2753, 3233)",
          "To encrypt m = 123: c = 123^17 mod 3233 = 855",
          "To decrypt c = 855: m = 855^2753 mod 3233 = 123"
        ]
      },
      "calculator": {
        "title": "RSA Calculator",
        "prime": "Prime",
        "generateKeys": "Generate Keys",
        "publicKey": "Public Key",
        "privateKey": "Private Key",
        "encrypt": "Encrypt",
        "decrypt": "Decrypt",
        "encrypted": "Encrypted",
        "decrypted": "Decrypted",
        "messageToEncrypt": "Message to Encrypt"
      }
    }
  },
  "graphTheory": {
    "introduction": {
      "title": "Introduction to Graph Theory",
      "graphDefinition": {
        "title": "Definition of a Graph",
        "definition": "A graph is a mathematical structure consisting of two sets:",
        "vertices": "V (vertices): A non-empty set of elements called vertices or nodes.",
        "edges": "E (edges): A set of pairs of vertices, representing connections between them.",
        "formal": "Formally, we write a graph as G = (V, E).",
        "explanation": "The graph above shows a simple undirected graph with 6 vertices and 9 edges.",
        "interactionPrompt": "You can click and drag the vertices to rearrange the graph!"
      },
      "graphDirectedness": {
        "title": "Undirected vs Directed Graphs",
        "definition": "Graphs can be classified as undirected or directed based on the nature of their edges:",
        "undirected": {
          "label": "Undirected Graph",
          "description": "Edges have no direction. The relationship between connected vertices is symmetric."
        },
        "directed": {
          "label": "Directed Graph (Digraph)",
          "description": "Edges have a direction. The relationship between connected vertices can be asymmetric."
        },
        "selectedEdge": "Selected edge: {{edge}}",
        "prompt": "Click on an edge in either graph to see the difference in representation.",
        "interactionPrompt": "Click on edges in both graphs to compare undirected and directed representations!"
      },
      "verticesAndEdges": {
        "title": "Vertices and Edges",
        "description": "A graph consists of two main elements:",
        "vertices": {
          "label": "Vertices (Nodes)",
          "description": "Points or circles in the graph"
        },
        "edges": {
          "label": "Edges",
          "description": "Lines connecting the vertices"
        },
        "explanation": "In the example graphs: The circles are vertices. The lines connecting these circles are edges. In the directed graph (right), edges have arrows indicating direction.",
        "interactionPrompt": "Click on \"Vertices\" or \"Edges\" above to highlight them in both graphs!",
        "undirectedGraph": "Undirected Graph",
        "directedGraph": "Directed Graph"
      },
      "vertexDegree": {
        "title": "Degree of a Vertex",
        "description": "The degree of a vertex is the number of edges connected to it. In other words, it's the number of neighbors a vertex has.",
        "undirectedGraphDescription": "For undirected graphs, it's simply the count of edges connected to the vertex.",
        "directedGraphDescription": "For directed graphs, we distinguish between in-degree (incoming edges) and out-degree (outgoing edges).",
        "undirectedGraph": "Undirected Graph",
        "directedGraph": "Directed Graph",
        "undirectedDegreeExplanation": "In the undirected graph, the degree of vertex {{selectedNode}} is {{undirectedDegree}}.",
        "directedDegreeExplanation": "In the directed graph, vertex {{selectedNode}} has in-degree {{inDegree}} and out-degree {{outDegree}}.",
        "selectVertexPrompt": "Click on a vertex in either graph to see its degree.",
        "interactionPrompt": "Click on different vertices in both graphs to compare degrees in undirected and directed graphs!"
      },
      "pathsAndCycles": {
        "title": "Paths and Cycles in Graphs",
        "description": "In graph theory, paths and cycles are fundamental concepts: A path is a sequence of nodes connected by edges, without repeating any node. A cycle is a path that starts and ends at the same node.",
        "pathExplanation": "This is a path: e → f → g → a → b → c → d. It's a sequence of connected nodes without repetition.",
        "cycleExplanation": "This is a cycle: a → b → c → f → g → a. It starts and ends at the same node.",
        "showPathButton": "Show Path",
        "showCycleButton": "Show Cycle",
        "interactiveDescription": "Create your own graph by clicking to add nodes and connecting them. Then detect cycles in your graph.",
        "resetButton": "Reset Graph",
        "cyclesDetected": "Cycle(s) detected in the graph",
        "interactivePrompt": "Click on the graph area to add nodes. Click on two nodes consecutively to create an edge between them. Use the 'Detect Cycles' button to find cycles in your graph."
      },
      "graphConnectivity": {
        "title": "Graph Connectivity",
        "description": "Graph connectivity refers to whether all nodes in a graph are connected. A graph is connected if there is a path between every pair of nodes.",
        "connectedGraph": "Connected Graph",
        "disconnectedGraph": "Disconnected Graph",
        "connectedExplanation": "In this connected graph, you can reach any node from any other node by following the edges.",
        "disconnectedExplanation": "This disconnected graph has two separate components. You cannot reach nodes C or D from A or B.",
        "additionalInfo": "A connected graph has only one component, while a disconnected graph has two or more components. Components are subgraphs where all nodes are connected to each other, but not to nodes in other components."
      },
      "subgraphs": {
        "title": "Subgraphs",
        "description": "A subgraph is a graph whose set of nodes and edges are subsets of another graph. It's like taking a piece of a larger graph while maintaining the connections between the selected elements.",
        "fullGraphExplanation": "This is the full graph. A subgraph is a subset of nodes and edges from this graph.",
        "triangleExplanation": "This triangle (A-B-C) is a subgraph. It includes some, but not all, of the original graph's nodes and edges.",
        "pathExplanation": "This path (B-C-D-E) is also a subgraph. It's a sequence of connected nodes that's part of the larger graph.",
        "showFullGraph": "Show Full Graph",
        "showTriangle": "Show Triangle Subgraph",
        "showPath": "Show Path Subgraph",
        "resetButton": "გადატვირთვა"
      }
    },
    "differentGraphs": {
      "title": "Different Kind of Graphs",
      "weightedGraphs": {
        "title": "Weighted Graphs",
        "description": "Weighted graphs are graphs in which each edge is assigned a numerical value, called a weight. These weights can represent various real-world quantities such as distance, cost, or capacity. There are two main types of weighted graphs:",
        "undirectedDescription": "Undirected Weighted Graphs: The edges have no direction, and the weight applies in both directions between the connected nodes.",
        "directedDescription": "Directed Weighted Graphs: The edges have a specific direction, and the weight applies only in that direction.",
        "undirectedGraph": "Undirected Weighted Graph",
        "directedGraph": "Directed Weighted Graph",
        "edgeWeightExplanation": "The selected edge {{selectedElement}} has a weight of {{weight}}.",
        "nodeExplanation": "You've selected node {{selectedElement}}. In a weighted graph, the weights are associated with edges, not nodes.",
        "selectElementPrompt": "Click on a node or edge to see more information.",
        "interactionPrompt": "Interact with the graphs above to explore the concept of weighted graphs. Click on edges to see their weights, or on nodes to understand their role in weighted graphs."
      },
      "planarGraphs": {
        "planarTitle": "Planar Graphs",
        "planarDescription": "A planar graph is a type of graph that can be drawn on a flat surface such that no edges cross, except at their vertices. This means the edges only intersect at their endpoints.",
        "planarLabel": "Planar Graph",
        "nonPlanarLabel": "Non-Planar Graph",
        "planarInteractionPrompt": "Adjust the slider to explore how the graph changes with different node counts. Observe the differences between planar and non-planar graphs.",
        "numberOfNodes": "Number of Nodes"
      },
      "bipartiteGraphs": {
        "title": "Bipartite Graphs",
        "description": "A bipartite graph is a graph whose vertices can be divided into two disjoint sets such that every edge connects a vertex in one set to a vertex in the other set. In other words, there are no edges between vertices within the same set.",
        "bipartiteLabel": "Bipartite Graph",
        "examples": {
          "0": "Students and Classes: One set represents students, the other represents classes. Edges show which students are enrolled in which classes.",
          "1": "Actors and Movies: One set for actors, another for movies. Edges show which actors appeared in which movies.",
          "2": "Authors and Books: One set for authors, another for books. Edges represent which authors wrote which books."
        },
        "applicationNote": "These examples demonstrate how bipartite graphs can represent relationships between two different types of entities, making them powerful tools for analyzing and visualizing various systems and networks.",
        "nonBipartiteLabel": "Non-Bipartite Graph",
        "interactionPrompt": "Use the slider below to change the number of nodes in both graphs. Notice how the bipartite graph always maintains two distinct sets of nodes, while the non-bipartite graph allows connections within the same set.",
        "numberOfNodes": "Number of Nodes"
      },
      "regularGraphs": {
        "title": "Regular Graphs",
        "description": "A regular graph is a graph where each vertex has the same number of neighbors; in other words, every vertex has the same degree. Regular graphs are fundamental in graph theory and have various applications in network design, chemistry, and social network analysis.",
        "numberOfVertices": "Number of Vertices",
        "degree": "Degree",
        "oddEvenDescription": "The number of vertices and the degree of a regular graph are closely related. For a regular graph to exist, the product of the number of vertices and the degree must be even. This is because each edge contributes to the degree of two vertices. As a result, regular graphs with an odd number of vertices must have an even degree, while graphs with an even number of vertices can have either an odd or even degree. Explore these relationships by adjusting the number of vertices and degree below.",
        "interactionPrompt": "Use the controls below to adjust the number of vertices and the degree. Observe how the regular graph changes and which combinations are possible or impossible."
      },
      "completeGraphs": {
        "title": "Complete Graphs",
        "description": "A complete graph is a graph in which every pair of distinct vertices is connected by a unique edge. In a complete graph with n vertices, each vertex has a degree of n-1, and the total number of edges is n(n-1)/2.",
        "interactionPrompt": "Use the controls below to adjust the number of vertices. Observe how the number of edges and the degree of each vertex change as you modify the graph.",
        "numberOfVertices": "Number of Vertices",
        "edgeCount": "Number of Edges: {{num}}",
        "degreeProp": "Degree of each vertex: {{degree}}"
      },
      "trees": {
        "title": "Trees",
        "description": "In graph theory, a tree is a connected, acyclic graph. Trees are used to represent hierarchies and enable efficient algorithms.",
        "tree1": "Binary Tree",
        "tree1Explanation": "A binary tree where each node has at most two children. Commonly used for efficient searching and sorting algorithms.",
        "tree2": "General Tree",
        "tree2Explanation": "A tree where nodes can have any number of children. Useful for representing complex hierarchies like file systems or organizational charts.",
        "interactionPrompt": "Interact with the trees!"
      }
    },
    "graphTraversals": {
      "title": "Graph Traversals",
      "bfs": {
        "title": "Breadth-First Search (BFS)",
        "explanation": "Breadth-First Search (BFS) is like exploring a city neighborhood by neighborhood. Imagine you're standing at your home (the starting node) and want to find a specific place. Instead of going down one long street at a time, you first visit all the places on your block. Then, you move to all the places one block away, then two blocks away, and so on. This way, you're sure to find the closest location first. In graph terms, BFS starts at a chosen node and explores all its neighbors before moving to the next level. It uses a queue (like a waiting line) to keep track of which nodes to visit next. This method ensures that nodes are visited in order of their distance from the start, making BFS ideal for finding the shortest path between two points in an unweighted graph.\n\nBFS is widely used in applications like social network friend suggestions, GPS navigation for finding nearby places, and even in puzzle-solving algorithms!",
        "demoDescription": "Watch the animation below to see how BFS explores a graph level by level:",
        "interactionDescription": "Now, try creating your own graph and run BFS to see how it works on different structures:",
        "interactionPrompt": "Click empty space to add nodes. Click two nodes in succession to create an edge. Click a node to set it as the start node (highlighted in green). Press play to begin BFS.",
        "unvisitedNode": "Unvisited Node",
        "visitedNode": "Visited Node",
        "currentNode": "Current Node",
        "queuedNode": "Queued Node",
        "traversedEdge": "Traversed Edge"
      },
      "dfs": {
        "title": "Depth-First Search (DFS)",
        "explanation": "Depth-First Search (DFS) is like exploring a maze by always choosing the deepest unexplored path. Imagine you're in a cave system: you keep going deeper into unexplored tunnels until you hit a dead end, then you backtrack to the last junction with an unexplored path. This method ensures you explore every possible path.",
        "demoDescription": "Watch the animation below to see how DFS explores a graph, always choosing the leftmost unexplored path first:",
        "interactionDescription": "Now, try creating your own graph and run DFS to see how it works on different structures:",
        "interactionPrompt": "Click to add nodes. Click two nodes to create an edge. Click a node to set as start. Press play to begin DFS.",
        "unvisitedNode": "Unvisited Node",
        "visitedNode": "Visited Node",
        "currentNode": "Current Node",
        "stackNode": "Node in Stack",
        "forwardEdge": "Explored Edge",
        "runDFS": "Run DFS",
        "resetGraph": "Reset Graph"
      }
    },
    "graphAlgorithms": {
      "title": "Graph Algorithms",
      "graphIsomorphism": {
        "title": "Graph Isomorphism",
        "introduction": "Graph isomorphism is a fundamental concept in graph theory that helps us understand when two graphs have the same structure, regardless of how they're drawn or labeled.",
        "definitionTitle": "What is Graph Isomorphism?",
        "definition": "Two graphs G and H are considered isomorphic if there exists a bijective function f from the vertices of G to the vertices of H such that any two vertices u and v are adjacent in G if and only if f(u) and f(v) are adjacent in H. In simpler terms, isomorphic graphs have the same structure and can be transformed into each other by relabeling the vertices.",
        "determinationTitle": "How to Determine Isomorphism",
        "determination": "Determining whether two graphs are isomorphic can be challenging. Here are some key steps:\n\n1. Check if the graphs have the same number of vertices and edges.\n2. Compare the degree sequences of both graphs.\n3. Look for cycles of the same length in both graphs.\n4. Check for the presence of similar subgraphs.\n\nHowever, these are necessary but not sufficient conditions. The only way to prove isomorphism is to find a bijective mapping between the vertices that preserves adjacency.",
        "exampleDescription": "Below are two isomorphic graphs. Although they look different, they have the same structure.",
        "isomorphicResult": "The graphs are isomorphic! They have the same structure despite potentially different layouts or labels.",
        "nonIsomorphicResult": "The graphs are not isomorphic. They have different structures.",
        "interactiveDescription": "Click on the graph area to add nodes. Click on two nodes consecutively to create an edge between them. Use the buttons below to check for isomorphism or reset the graphs."
      },
      "spanningTree": {
        "title": "Graph Spanning Trees",
        "introduction": "A spanning tree is a fundamental concept in graph theory, with important applications in network design, circuit analysis, and algorithms. This interactive demonstration will help you understand how spanning trees work and how they're constructed.",
        "definitionTitle": "What is a Spanning Tree?",
        "definition": "A spanning tree of an undirected graph is a subgraph that includes all the vertices of the original graph, with the minimum possible number of edges to form a tree (a connected graph without cycles). In other words, a spanning tree reaches all nodes while avoiding any loops.",
        "algorithmTitle": "How to Find a Spanning Tree",
        "algorithm": "There are several algorithms to find a spanning tree. A common approach is to use Breadth-First Search (BFS):\n1. Start from any node in the graph.\n2. Explore all unvisited neighboring nodes.\n3. For each unvisited neighbor, add the edge connecting it to the current node to the spanning tree.\n4. Repeat steps 2-3 until all nodes are visited.\nThis process ensures we reach all nodes with the minimum number of edges, creating a valid spanning tree.",
        "exampleDescription": "Here's an example graph with a highlighted spanning tree. The teal nodes and orange edges represent the spanning tree.",
        "exampleExplanation": "In this example, we have a graph with 8 nodes (A through H) and 12 edges. The highlighted spanning tree contains 7 edges, which is the minimum number needed to connect all 8 nodes without forming any cycles. Notice how the spanning tree reaches every node in the graph, but some edges from the original graph are not included. This demonstrates how a spanning tree maintains connectivity while minimizing the number of edges used.",
        "interactiveDescription": "Now it's your turn! Click on the graph area to add nodes. Click on two nodes consecutively to create an edge between them. Use the 'Play' button to find a spanning tree, and the 'Delete' button to reset the graph.",
        "spanningTreeFound": "Spanning Tree Found!",
        "spanningTreeFoundDescription": "A spanning tree has been successfully found and highlighted in the graph.",
        "spanningTreeNotFound": "Spanning Tree Not Found",
        "spanningTreeNotFoundDescription": "A spanning tree could not be found. This happens when the graph is not connected (i.e., there are isolated nodes or subgraphs)."
      },
      "graphColoring": {
        "title": "Graph Coloring",
        "introduction": "Graph coloring is a fundamental concept in graph theory with various practical applications.",
        "definitionTitle": "Definition",
        "definition": "Graph coloring is the assignment of colors to the vertices of a graph such that no two adjacent vertices share the same color.",
        "algorithmTitle": "Algorithm",
        "algorithm": "A simple greedy algorithm for graph coloring works by iterating through the vertices and assigning the first available color that hasn't been used by any adjacent vertices.",
        "exampleDescription": "Here's a simple graph demonstrating the coloring algorithm:",
        "exampleExplanation": "Notice how no two connected nodes share the same color.",
        "interactiveDescription": "Create your own graph by clicking on the canvas to add nodes. Click on two nodes to connect them with an edge. Then use the buttons below to color the graph or reset it.",
        "resultTitle": "Coloring Result",
        "resultDescription": "The graph has been colored successfully. Observe how the algorithm minimized the number of colors used while ensuring no adjacent nodes share the same color.",
        "usedColors": "Number of colors used: {{count}}"
      }
    },
    "graphProblems": {
      "title": "Problems for Graph Theory"
    }
  }
}
