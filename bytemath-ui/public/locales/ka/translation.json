{
  "title": "მათემატიკა კომპიუტერული მეცნიერებისთვის",
  "courses": "კურსები",
  "signIn": "შესვლა",
  "signOut": "გასვლა",
  "introduction_to_logical_operators_title": "შესავალი: ლოგიკური ოპერატორები",
  "calculate": "გამოთვლა",
  "binarySystemTitle": "ორობითი სისტემა",
  "logicalOperandsTitle": "ლოგიკური ოპერატორები",
  "graphTheoryTitle": "გრაფთა თეორია",
  "numberTheoryTitle": "რიცხვთა თეორია",
  "introduction": "შესავალი",
  "lcm-gcd": "უ.ს.ჯ და უ.ს.გ",
  "rsa-algorithm": "RSA ალგორითმი",
  "modular-arithmetic": "მოდულარული არითმეტიკა",
  "quizResults": "ქვიზის შედეგები",
  "question": "შეკითხვა",
  "yourAnswer": "თვქენი პასუხი",
  "correctAnswer": "სწორი პასუხი",
  "totalScore": "ჯამური ქულა",
  "tryAgain": "თავიდან ცდა",
  "correct": "სწორია",
  "incorrect": "არასწორია",
  "decimalValue": "ათობითი მნიშვნელობა",
  "converting": "კონვერტაცია",
  "binaryArithmetic": "ორობითი არითმეტიკა",
  "clickToExplore": "დააწკაპუნეთ, რომ გაეცნოთ კურსს",
  "welcome": "მოგესალმებით",
  "binarySystem": {
    "introduction": {
      "title": "ორობითი სისტემის გაგება",
      "introduction": "ორობითი სისტემა, ასევე ცნობილი როგორც ორობითი რიცხვითი სისტემა, ფუნდამენტურია კომპიუტერულ მეცნიერებასა და ციფრულ ელექტრონიკაში. ის წარმოადგენს ყველა ციფრული მონაცემის წარმოდგენისა და დამუშავების საფუძველს.",
      "fundamentals": {
        "title": "ორობითის საფუძვლები",
        "description": "ორობითი სისტემა დაფუძნებულია ორ ციფრზე: 0 და 1, ცნობილი როგორც ბიტები (ორობითი ციფრები). აი რამდენიმე ძირითადი პუნქტი:",
        "points": [
          "ორობითი იყენებს მხოლოდ ორ ციფრს ათობითის ათ ციფრთან შედარებით.",
          "თითოეული ციფრის პოზიცია წარმოადგენს 2-ის ხარისხს.",
          "უკიდურესი მარჯვენა ციფრი წარმოადგენს 2^0-ს (1), შემდეგი 2^1-ს (2), შემდეგ 2^2-ს (4) და ა.შ.",
          "ორობით რიცხვებს შეუძლიათ წარმოადგინონ ნებისმიერი რაოდენობა, რასაც ათობითი რიცხვები წარმოადგენენ."
        ]
      },
      "whyBinary": {
        "title": "რატომ გამოიყენება ორობითი კომპიუტერებში",
        "description": "ორობითი არის კომპიუტერების ენა რამდენიმე მიზეზის გამო:",
        "points": [
          "ელექტრონულ სქემებს აქვთ ორი სტაბილური მდგომარეობა, რაც ორობითს ბუნებრივ შესაბამისობას ანიჭებს.",
          "უფრო ადვილი და საიმედოა ორ მდგომარეობას შორის განსხვავების დადგენა, ვიდრე მრავალ მდგომარეობას შორის.",
          "ორობითი ოპერაციები შეიძლება ეფექტურად განხორციელდეს ციფრული ლოგიკის კარიბჭეებით.",
          "შეცდომების აღმოჩენა და გასწორება უფრო მარტივია ორობით სისტემაში."
        ]
      },
      "binaryNumbers": {
        "title": "ორობითი რიცხვების გაგება",
        "description": "ორობითი რიცხვები მუშაობს ათობითი რიცხვების მსგავსად, მაგრამ 2-ის ფუძით 10-ის ნაცვლად:",
        "points": [
          "ორობითი რიცხვი 1011 ეკვივალენტურია ათობითი რიცხვის 11 (1*2^3 + 0*2^2 + 1*2^1 + 1*2^0).",
          "ყოველი დამატებითი ბიტი აორმაგებს წარმოდგენილი რიცხვების დიაპაზონს.",
          "8 ბიტს (ბაიტს) შეუძლია წარმოადგინოს რიცხვები 0-დან 255-მდე.",
          "წამყვანი ნულები არ ცვლიან ორობითი რიცხვის მნიშვნელობას."
        ]
      },
      "binaryOperations": {
        "title": "ძირითადი ორობითი ოპერაციები",
        "description": "არითმეტიკა ორობით სისტემაში მიჰყვება მსგავს წესებს, რაც ათობითში, მაგრამ მხოლოდ ორი ციფრით:",
        "points": [
          "შეკრება: 1 + 1 = 10 ორობითში (გადაიტანე 1)",
          "გამოკლება: საჭიროების შემთხვევაში ისესხე შემდეგი სვეტიდან",
          "გამრავლება: მსგავსია ათობითის, მაგრამ უფრო მარტივი, რადგან მხოლოდ 0-ზე ან 1-ზე ამრავლებ",
          "გაყოფა: შეიძლება შესრულდეს განმეორებითი გამოკლებითა და გადაწევით"
        ]
      },
      "applications": {
        "title": "ორობითი სისტემის გამოყენებები",
        "description": "ორობითი სისტემა კრიტიკულად მნიშვნელოვანია კომპიუტინგისა და ტექნოლოგიის მრავალ სფეროში:",
        "points": [
          "მონაცემთა შენახვა: ყველა მონაცემი კომპიუტერებში საბოლოოდ ინახება ორობით ფორმატში.",
          "ციფრული ლოგიკა: კომპიუტერის პროცესორები იყენებენ ორობითს ყველა თავიანთი ოპერაციისთვის.",
          "ქსელური კავშირი: მონაცემთა გადაცემა ქსელებში იყენებს ორობით კოდირებას.",
          "გამოსახულებისა და ხმის დამუშავება: ციფრული მედია წარმოდგენილია და მუშავდება ორობით ფორმატში.",
          "კრიპტოგრაფია: ბევრი დაშიფვრის ალგორითმი ეყრდნობა ორობით ოპერაციებს."
        ]
      }
    },
    "binaryConversion": {
      "title": "ორობითი კონვერსიის გაღრმავებული კურსი",
      "introduction": "ორობითი კონვერსია არის ფუნდამენტური უნარი კომპიუტერულ მეცნიერებასა და ციფრულ სისტემებში. ორობით და ათობით სისტემებს შორის კონვერსიის პროცესის გაგება კრიტიკულად მნიშვნელოვანია კომპიუტერებთან დაბალ დონეზე მუშაობისთვის.",
      "binaryToDecimal": {
        "title": "ორობითიდან ათობითში გადაყვანა",
        "description": "ორობითი რიცხვის ათობითში გადასაყვანად, უნდა შევაჯამოთ თითოეული ბიტის და მისი შესაბამისი 2-ის ხარისხის ნამრავლები. მარჯვენა უკიდურესი ბიტი შეესაბამება 2^0-ს, შემდეგი 2^1-ს და ა.შ.",
        "example": "მაგალითი: 1011 (ორობითი) = (1 * 2^3) + (0 * 2^2) + (1 * 2^1) + (1 * 2^0) = 8 + 0 + 2 + 1 = 11 (ათობითი)"
      },
      "decimalToBinary": {
        "title": "ათობითიდან ორობითში გადაყვანა",
        "description": "ათობითი რიცხვის ორობითში გადასაყვანად, მრავალჯერადად გავყოთ რიცხვი 2-ზე და ჩავიწეროთ ნაშთები. ორობითი წარმოდგენა არის ნაშთების თანმიმდევრობა ქვემოდან ზემოთ წაკითხვისას.",
        "example": "მაგალითი: 11 (ათობითი) ორობითში:\n11 / 2 = 5 ნაშთი 1\n5 / 2 = 2 ნაშთი 1\n2 / 2 = 1 ნაშთი 0\n1 / 2 = 0 ნაშთი 1\nქვემოდან ზემოთ წაკითხვისას: 1011 (ორობითი)"
      },
      "fractions": {
        "title": "ორობითი წილადები და მცურავი წერტილის რიცხვები",
        "description": "ორობითს ასევე შეუძლია წილადი რიცხვების წარმოდგენა. წილადი ნაწილისთვის, მრავალჯერადად გავამრავლოთ 2-ზე, ყოველ ჯერზე მთელი ნაწილის აღება, როგორც შემდეგი ორობითი ციფრი.",
        "example": "მაგალითი: 0.625 (ათობითი) ორობითში:\n0.625 * 2 = 1.25 (1)\n0.25 * 2 = 0.5 (0)\n0.5 * 2 = 1.0 (1)\nშედეგი: 0.101 (ორობითი)"
      },
      "negativeNumbers": {
        "title": "უარყოფითი რიცხვების წარმოდგენა",
        "description": "კომპიუტერები ჩვეულებრივ იყენებენ ორის დამატებას უარყოფითი რიცხვების წარმოსადგენად. რიცხვის ორის დამატების საპოვნელად, შევაბრუნოთ ყველა ბიტი და დავუმატოთ 1.",
        "example": "მაგალითი: -5 8-ბიტიან ორის დამატებაში:\n5 ორობითში: 00000101\nყველა ბიტის შებრუნება: 11111010\n1-ის დამატება: 11111011\nამრიგად, -5 წარმოდგენილია როგორც 11111011 ორის დამატებაში"
      },
      "applications": {
        "title": "პრაქტიკული გამოყენებები",
        "description": "ორობითი კონვერსიის გაგება კრიტიკულად მნიშვნელოვანია კომპიუტინგის მრავალ სფეროში:",
        "list": [
          "ციფრული სქემების დიზაინი და ანალიზი",
          "დაბალი დონის პროგრამირება და ჩაშენებული სისტემები",
          "ქსელის პროტოკოლები და მონაცემთა გადაცემა",
          "კრიპტოგრაფია და მონაცემთა უსაფრთხოება",
          "კომპიუტერული გრაფიკა და გამოსახულების დამუშავება"
        ]
      },
      "advancedTopics": {
        "title": "გაღრმავებული ორობითი თემები",
        "description": "ძირითადი კონვერსიის გარდა, არსებობს რამდენიმე გაღრმავებული თემა, დაკავშირებული ორობით წარმოდგენასთან:",
        "list": [
          "IEEE 754 მცურავი წერტილის წარმოდგენა",
          "ორობით-კოდირებული ათობითი (BCD)",
          "გრეის კოდი და მისი გამოყენებები",
          "თექვსმეტობითი, როგორც ორობითის კომპაქტური წარმოდგენა",
          "შეცდომების აღმოჩენისა და გასწორების კოდები (მაგ., ჰემინგის კოდები)"
        ]
      }
    },
    "binaryArithmetic": {
      "title": "გაღრმავებული ორობითი არითმეტიკა",
      "introduction": "ორობითი არითმეტიკა მუშაობს ათობითი არითმეტიკის მსგავსად, მაგრამ მიჰყვება ორობითი რიცხვითი სისტემის წესებს. ამ ოპერაციების გაგება მნიშვნელოვანია დაბალი დონის პროგრამირებისა და კომპიუტერის არქიტექტურისთვის.",
      "addition": {
        "title": "ორობითი შეკრება",
        "description": "ორობითი შეკრება ათობითი შეკრების მსგავსია, მაგრამ მხოლოდ ორი ციფრით. მთავარია გვახსოვდეს, რომ 1 + 1 ორობითში უდრის 10-ს (2-ს ათობითში).",
        "table": [
          { "A": "0", "B": "0", "ჯამი": "0", "გადატანა": "0" },
          { "A": "0", "B": "1", "ჯამი": "1", "გადატანა": "0" },
          { "A": "1", "B": "0", "ჯამი": "1", "გადატანა": "0" },
          { "A": "1", "B": "1", "ჯამი": "0", "გადატანა": "1" }
        ],
        "example": "მაგალითი: 1011-ისა და 1101-ის შეკრება\n  1011\n+ 1101\n------\n 10100"
      },
      "subtraction": {
        "title": "ორობითი გამოკლება",
        "description": "ორობითი გამოკლება მიჰყვება ათობითი გამოკლების მსგავს პრინციპებს, საჭიროების შემთხვევაში სესხებით.",
        "table": [
          { "A": "0", "B": "0", "სხვაობა": "0", "სესხი": "0" },
          { "A": "0", "B": "1", "სხვაობა": "1", "სესხი": "1" },
          { "A": "1", "B": "0", "სხვაობა": "1", "სესხი": "0" },
          { "A": "1", "B": "1", "სხვაობა": "0", "სესხი": "0" }
        ],
        "example": "მაგალითი: 1011-ის გამოკლება 1101-დან\n  1101\n- 1011\n------\n  0010"
      },
      "multiplication": {
        "title": "ორობითი გამრავლება",
        "description": "ორობითი გამრავლება უფრო მარტივია ვიდრე ათობითი გამრავლება, რადგან მხოლოდ 0-ებსა და 1-ებს მოიცავს.",
        "table": [
          { "A": "0", "B": "0", "ნამრავლი": "0" },
          { "A": "0", "B": "1", "ნამრავლი": "0" },
          { "A": "1", "B": "0", "ნამრავლი": "0" },
          { "A": "1", "B": "1", "ნამრავლი": "1" }
        ],
        "example": "მაგალითი: 101-ის გამრავლება 11-ზე\n  101\n×  11\n-----\n  101\n 101\n-----\n 1111"
      },
      "division": {
        "title": "ორობითი გაყოფა",
        "description": "ორობითი გაყოფა მიჰყვება ათობითი გაყოფის იმავე პრინციპებს, მაგრამ იყენებს ორობით რიცხვებს.",
        "example": "მაგალითი: 1010-ის გაყოფა 10-ზე\n  101\n-------\n10 | 1010\n    - 10\n    ----\n      10\n     -10\n    ----\n       0"
      },
      "advancedTopics": {
        "title": "გაღრმავებული ორობითი არითმეტიკის კონცეფციები",
        "description": "ძირითადი ოპერაციების გარდა, არსებობს რამდენიმე გაღრმავებული თემა ორობით არითმეტიკაში:",
        "list": [
          "ორის შევსების წარმოდგენა ნიშნიანი მთელი რიცხვებისთვის",
          "მცურავი წერტილის არითმეტიკა (IEEE 754 სტანდარტი)",
          "ბიტური ოპერაციები (AND, OR, XOR, NOT)",
          "არითმეტიკული და ლოგიკური წანაცვლებები",
          "მიმდევრობითი გადატანის შემკრები და სხვა სწრაფი შეკრების ტექნიკები",
          "ბუთის გამრავლების ალგორითმი",
          "არააღდგენითი გაყოფის ალგორითმი"
        ]
      },
      "applications": {
        "title": "ორობითი არითმეტიკის გამოყენებები",
        "description": "ორობითი არითმეტიკა ფუნდამენტურია კომპიუტინგის მრავალ სფეროში:",
        "list": [
          "ALU-ს (არითმეტიკულ-ლოგიკური მოწყობილობა) დიზაინი პროცესორებში",
          "მცურავი წერტილის თანაპროცესორები",
          "ციფრული სიგნალების დამუშავება",
          "კრიპტოგრაფიული ალგორითმები",
          "შეცდომების აღმოჩენისა და გასწორების კოდები",
          "კომპიუტერული გრაფიკა (მაგ., მატრიცული ოპერაციები)",
          "მანქანური სწავლების აქსელერატორები"
        ]
      }
    }
  },
  "numberTheory": {
    "introduction": {
      "title": "შესავალი რიცხვთა თეორიაში",
      "description": "რიცხვთა თეორია არის წმინდა მათემატიკის დარგი, რომელიც ძირითადად ეძღვნება მთელი რიცხვებისა და მთელრიცხვა ფუნქციების შესწავლას. ეს არის მათემატიკის ერთ-ერთი უძველესი და ფუნდამენტური სფერო, მდიდარი ისტორიით, რომელიც უძველეს ცივილიზაციებამდე მიდის.",
      "keyConcepts": {
        "title": "ძირითადი კონცეფციები რიცხვთა თეორიაში:",
        "list": [
          "მარტივი რიცხვები: 1-ზე მეტი რიცხვები, რომლებსაც არ აქვთ სხვა დადებითი გამყოფები გარდა 1-ისა და საკუთარი თავისა.",
          "გაყოფადობა: იმის შესწავლა, თუ როდის არის ერთი მთელი რიცხვი გაყოფადი მეორეზე.",
          "უდიდესი საერთო გამყოფი (უსგ): უდიდესი დადებითი მთელი რიცხვი, რომელიც ყოფს თითოეულ რიცხვს ნაშთის გარეშე.",
          "უმცირესი საერთო ჯერადი (უსჯ): უმცირესი დადებითი მთელი რიცხვი, რომელიც იყოფა თითოეულ რიცხვზე.",
          "მოდულური არითმეტიკა: არითმეტიკა, რომელიც ეხება ნაშთებს გაყოფის შემდეგ.",
          "დიოფანტური განტოლებები: პოლინომიალური განტოლებები, სადაც მხოლოდ მთელრიცხვა ამონახსნები იძებნება."
        ]
      },
      "applications": {
        "title": "რიცხვთა თეორიის გამოყენებები:",
        "list": [
          "კრიპტოგრაფია: ბევრი დაშიფვრის მეთოდი, მათ შორის RSA, დაფუძნებულია რიცხვთა თეორიის პრინციპებზე.",
          "კომპიუტერული მეცნიერება: ალგორითმები, მონაცემთა სტრუქტურები და შეცდომების გასწორების კოდები ხშირად ეყრდნობა რიცხვთა თეორიის კონცეფციებს.",
          "ფიზიკა: რიცხვთა თეორია გამოიყენება თეორიული ფიზიკის სხვადასხვა სფეროში, მათ შორის სიმების თეორიაში.",
          "ინჟინერია: გამოყენებები სიგნალების დამუშავებაში, მართვის თეორიაში და სხვა საინჟინრო სფეროებში."
        ]
      },
      "conclusion": "რიცხვთა თეორია კვლავ რჩება კვლევის აქტიურ სფეროდ, ბევრი გადაუჭრელი პრობლემითა და ჰიპოთეზით, რომლებმაც საუკუნეების მანძილზე დააბნიეს მათემატიკოსები."
    },
    "lcmAndGcd": {
      "title": "უმცირესი საერთო ჯერადი (უსჯ) და უდიდესი საერთო გამყოფი (უსგ)",
      "whatAre": {
        "title": "რა არის უსჯ და უსგ?",
        "lcm": {
          "title": "უმცირესი საერთო ჯერადი (უსჯ)",
          "description": "ორი ან მეტი მთელი რიცხვის უსჯ არის უმცირესი დადებითი მთელი რიცხვი, რომელიც იყოფა თითოეულ ამ რიცხვზე. მაგალითად, 4-ისა და 6-ის უსჯ არის 12."
        },
        "gcd": {
          "title": "უდიდესი საერთო გამყოფი (უსგ)",
          "description": "ორი ან მეტი მთელი რიცხვის უსგ არის უდიდესი დადებითი მთელი რიცხვი, რომელიც ყოფს თითოეულ ამ რიცხვს ნაშთის გარეშე. მაგალითად, 8-ისა და 12-ის უსგ არის 4."
        }
      },
      "importance": {
        "title": "რატომ არის მნიშვნელოვანი უსჯ და უსგ?",
        "list": [
          "უსჯ გამოიყენება მათემატიკის მრავალ სფეროში, მათ შორის წილადებში, ალგებრაში და რიცხვთა თეორიაში.",
          "უსგ ფუნდამენტურია წილადების გამარტივებაში, დიოფანტური განტოლებების ამოხსნაში და კომპიუტერულ მეცნიერებაში სხვადასხვა ალგორითმებში.",
          "როგორც უსჯ, ისე უსგ მნიშვნელოვანია კრიპტოგრაფიაში, განსაკუთრებით RSA ალგორითმში.",
          "კომპიუტერულ პროგრამირებაში, უსჯ და უსგ გამოიყენება სხვადასხვა ალგორითმებსა და მონაცემთა სტრუქტურებში."
        ]
      },
      "calculation": {
        "title": "როგორ გამოვთვალოთ უსჯ და უსგ",
        "gcd": {
          "title": "უსგ-ს გამოთვლა",
          "description": "უსგ-ს გამოსათვლელად ყველაზე ეფექტური მეთოდია ევკლიდეს ალგორითმი:",
          "steps": [
            "გაყავით დიდი რიცხვი პატარაზე.",
            "შეცვალეთ დიდი რიცხვი პატარა რიცხვით, ხოლო პატარა რიცხვი - პირველი ნაბიჯის ნაშთით.",
            "გაიმეორეთ, სანამ ნაშთი არ გახდება ნული. ბოლო არანულოვანი ნაშთი არის უსგ."
          ]
        },
        "lcm": {
          "title": "უსჯ-ს გამოთვლა",
          "description": "უსჯ შეიძლება გამოითვალოს შემდეგი ფორმულით:",
          "formula": "უსჯ(a, b) = |a * b| / უსგ(a, b)",
          "note": "სადაც |a * b| აღნიშნავს a * b-ს აბსოლუტურ მნიშვნელობას."
        }
      },
      "examples": {
        "title": "მაგალითები",
        "gcd": {
          "title": "უსგ-ს მაგალითი: გამოვთვალოთ უსგ(48, 18)",
          "steps": [
            "48 ÷ 18 = 2 ნაშთი 12",
            "18 ÷ 12 = 1 ნაშთი 6",
            "12 ÷ 6 = 2 ნაშთი 0",
            "ბოლო არანულოვანი ნაშთი არის 6, ამიტომ უსგ(48, 18) = 6"
          ]
        },
        "lcm": {
          "title": "უსჯ-ს მაგალითი: გამოვთვალოთ უსჯ(12, 18)",
          "steps": [
            "ჯერ გამოვთვალოთ უსგ(12, 18) = 6",
            "შემდეგ, უსჯ(12, 18) = |12 * 18| / 6 = 216 / 6 = 36"
          ]
        }
      },
      "calculator": {
        "enterFirstNumber": "შეიყვანეთ პირველი რიცხვი",
        "enterSecondNumber": "შეიყვანეთ მეორე რიცხვი",
        "lcm": "უ.ს.ჯ",
        "gcd": "უ.ს.გ"
      }
    },
    "modularArithmetic": {
      "title": "მოდულარული არითმეტიკა",
      "introduction": {
        "title": "რა არის მოდულარული არითმეტიკა?",
        "description": "მოდულარული არითმეტიკა არის არითმეტიკული სისტემა მთელი რიცხვებისთვის, სადაც რიცხვები \"ბრუნდება\" გარკვეული მნიშვნელობის - მოდულის მიღწევის შემდეგ. ის ხშირად აღწერილია როგორც \"საათის არითმეტიკა\", რადგან ის ჰგავს საათზე საათების 12-დან 1-ზე გადასვლას."
      },
      "keyConcepts": {
        "title": "ძირითადი კონცეფციები",
        "list": [
          "კონგრუენტულობა: ვამბობთ, რომ a კონგრუენტულია b-სთან მოდულით m, თუ m ყოფს (a-b)-ს. ჩვენ ამას ვწერთ როგორც a ≡ b (mod m).",
          "მოდულარული შეკრება: (a + b) mod m = ((a mod m) + (b mod m)) mod m",
          "მოდულარული გამოკლება: (a - b) mod m = ((a mod m) - (b mod m) + m) mod m",
          "მოდულარული გამრავლება: (a * b) mod m = ((a mod m) * (b mod m)) mod m",
          "მოდულარული ახარისხება: a^b mod m = ((a mod m)^b) mod m"
        ]
      },
      "applications": {
        "title": "გამოყენებები",
        "description": "მოდულარულ არითმეტიკას აქვს მრავალი გამოყენება კომპიუტერულ მეცნიერებასა და კრიპტოგრაფიაში:",
        "list": [
          "ჰეშ ფუნქციები",
          "შემთხვევითი რიცხვების გენერაცია",
          "შეცდომების აღმოჩენისა და გასწორების კოდები",
          "კრიპტოგრაფიული ალგორითმები (როგორიცაა RSA)"
        ]
      },
      "calculator": {
        "title": "მოდულარული არითმეტიკის კალკულატორი",
        "result": "შედეგი: {{a}} {{operation}} {{b}} ≡ {{result}} (mod {{m}})"
      }
    },
    "rsaAlgorithm": {
      "title": "RSA ალგორითმი",
      "whatIsRSA": {
        "title": "რა არის RSA?",
        "description1": "RSA (Rivest-Shamir-Adleman) არის საჯარო გასაღების კრიპტოსისტემა, რომელიც ფართოდ გამოიყენება უსაფრთხო მონაცემთა გადაცემისთვის. ეს არის ასიმეტრიული კრიპტოგრაფიული ალგორითმი, რაც ნიშნავს, რომ იგი იყენებს ორ სხვადასხვა გასაღებს: საჯარო გასაღებს დაშიფვრისთვის და პირად გასაღებს გაშიფვრისთვის.",
        "description2": "RSA პირველად აღწერეს 1977 წელს რონ რივესტმა, ადი შამირმა და ლეონარდ ადლემანმა MIT-ში. ასოები RSA არის მათი გვარების ინიციალები. ეს იყო ერთ-ერთი პირველი პრაქტიკული საჯარო გასაღების კრიპტოსისტემა და კვლავ ფართოდ გამოიყენება უსაფრთხო მონაცემთა გადაცემისთვის."
      },
      "importance": {
        "title": "RSA-ს მნიშვნელობა",
        "list": [
          "უსაფრთხოება: RSA-ს უსაფრთხოება ეფუძნება ორი დიდი მარტივი რიცხვის ნამრავლის ფაქტორიზაციის პრაქტიკულ სირთულეს, რაც ცნობილია როგორც ფაქტორიზაციის პრობლემა.",
          "ციფრული ხელმოწერები: RSA შეიძლება გამოყენებულ იქნას ციფრული ხელმოწერების შესაქმნელად, რაც უზრუნველყოფს ციფრული შეტყობინებების ან დოკუმენტების ავთენტურობასა და მთლიანობას.",
          "გასაღების გაცვლა: იგი საშუალებას იძლევა უსაფრთხოდ გაცვალოთ გასაღებები არაუსაფრთხო არხებზე, რაც მნიშვნელოვანია უსაფრთხო კომუნიკაციის დამყარებისთვის.",
          "ფართო გამოყენება: RSA გამოიყენება მრავალ პროტოკოლში, მათ შორის SSL/TLS-ში, რომელიც გამოიყენება ინტერნეტ კომუნიკაციების დასაცავად."
        ]
      },
      "howItWorks": {
        "title": "როგორ მუშაობს RSA: დეტალური ნაბიჯები",
        "keyGeneration": {
          "title": "1. გასაღების გენერაცია:",
          "steps": [
            "აირჩიეთ ორი განსხვავებული დიდი მარტივი რიცხვი p და q.",
            "გამოთვალეთ n = p * q. ეს n იწოდება მოდულად როგორც საჯარო, ისე პირადი გასაღებებისთვის.",
            "გამოთვალეთ φ(n) = (p-1) * (q-1). ეს არის ეილერის ფუნქცია.",
            "აირჩიეთ მთელი რიცხვი e ისე, რომ 1 < e < φ(n) და gcd(e, φ(n)) = 1. ეს e არის საჯარო ექსპონენტი.",
            "გამოთვალეთ d როგორც e-ს მოდულარული მულტიპლიკაციური შებრუნება (mod φ(n)). ეს d არის პირადი ექსპონენტი."
          ]
        },
        "keyDistribution": {
          "title": "2. გასაღების განაწილება:",
          "steps": [
            "საჯარო გასაღებია (e, n). ეს შეიძლება ცნობილი იყოს ყველასთვის და გამოიყენება დაშიფვრისთვის.",
            "პირადი გასაღებია (d, n). ეს უნდა იყოს საიდუმლოდ შენახული და გამოიყენება გაშიფვრისთვის."
          ]
        },
        "encryption": {
          "title": "3. დაშიფვრა:",
          "steps": [
            "გადაიყვანეთ შეტყობინება რიცხვში m, სადაც 0 ≤ m < n.",
            "გამოთვალეთ შიფროტექსტი c = m^e mod n."
          ]
        },
        "decryption": {
          "title": "4. გაშიფვრა:",
          "steps": [
            "გამოიყენეთ პირადი გასაღები (d, n) m-ის გამოსათვლელად: m = c^d mod n.",
            "გადაიყვანეთ m უკან ორიგინალ შეტყობინებაში."
          ]
        }
      },
      "mathematicalFoundation": {
        "title": "მათემატიკური საფუძველი",
        "description": "RSA-ს უსაფრთხოება ეფუძნება ორ მათემატიკურ ფაქტს:",
        "fact1": "1. მოდულარული ახარისხება: გამოთვლითად ადვილია n = p * q და c = m^e mod n გამოთვლა.",
        "fact2": "2. მარტივ მამრავლებად დაშლა: გამოთვლითად რთულია p-ს და q-ს განსაზღვრა n-დან, განსაკუთრებით მაშინ, როცა p და q დიდი მარტივი რიცხვებია.",
        "additional": "ალგორითმი ასევე ეყრდნობა ეილერის თეორემას და მოდულარული არითმეტიკის თვისებებს, რათა უზრუნველყოს, რომ დაშიფვრა და გაშიფვრა არიან შებრუნებული ოპერაციები."
      },
      "securityConsiderations": {
        "title": "უსაფრთხოების მოსაზრებები",
        "list": [
          "გასაღების ზომა: RSA-ს უსაფრთხოება დამოკიდებულია n-ის ზომაზე. 2021 წლის მდგომარეობით, 2048 ბიტის ზომის გასაღები ითვლება უსაფრთხოდ უმეტესი გამოყენებისთვის.",
          "მარტივი რიცხვების გენერაცია: მარტივი რიცხვები p და q უნდა იყოს გენერირებული შემთხვევითად და შენახული საიდუმლოდ.",
          "დამატებითი შევსება: პრაქტიკაში, RSA ხშირად გამოიყენება დამატებითი შევსების სქემებთან ერთად, როგორიცაა OAEP, უსაფრთხოების გასაძლიერებლად.",
          "გვერდითი არხის შეტევები: იმპლემენტაციები უნდა იყოს ფრთხილი, რათა თავიდან აიცილოს ინფორმაციის გაჟონვა დროის ან ენერგიის მოხმარების გზით."
        ]
      },
      "practicalExample": {
        "title": "პრაქტიკული მაგალითი",
        "description": "განვიხილოთ მარტივი მაგალითი პატარა რიცხვებით (შენიშვნა: პრაქტიკაში გამოიყენება გაცილებით დიდი რიცხვები):",
        "steps": [
          "ავიღოთ p = 61 და q = 53",
          "დავთვალოთ n = 61 * 53 = 3233",
          "დავთვალოთ φ(n) = (61-1) * (53-1) = 3120",
          "ავიღოთ e = 17 (თანამარტივი 3120-თან)",
          "ვიპოვოთ ისეთი d, რომ (d * 17) mod 3120 = 1. d = 2753",
          "საჯარო გასაღებია (17, 3233), საიდუმლო გასაღები არის (2753, 3233)",
          "m = 123-ის დასაშიფრად: c = 123^17 mod 3233 = 855",
          "c = 855-ის გასაშიფრად: m = 855^2753 mod 3233 = 123"
        ]
      },
      "calculator": {
        "title": "RSA ალგორითმის კალკულატორი",
        "prime": "მარტივი რიცხვი",
        "generateKeys": "გასაღების გენერაცია",
        "publicKey": "საჯარო გასაღები",
        "privateKey": "საიდუმლო გასაღები",
        "encrypt": "დაშიფვრა",
        "decrypt": "გაშიფვრა",
        "encrypted": "დაშიფრული შეტყობინება",
        "decrypted": "გაშიფრული შეტყობინება",
        "messageToEncrypt": "დასაშიფრი შეტყობინება"
      }
    }
  },
  "graphTheory": {
    "introduction": {
      "title": "შესავალი გრაფთა თეორიაში",
      "graphDefinition": {
        "title": "გრაფის განმარტება",
        "definition": "გრაფი არის მათემატიკური სტრუქტურა, რომელიც შედგება ორი სიმრავლისგან:",
        "vertices": "V (წვეროები): ელემენტების არასაცარიელი სიმრავლე, რომელსაც ეწოდება წვეროები.",
        "edges": "E (წიბოები): სიმრავლე წვეროების წყვილებისა, რომლებიც მათ შორის კავშირს ასახავენ.",
        "formal": "მათემატიკურად, გრაფი ჩაიწერება როგორც: G = (V, E).",
        "explanation": "ზემოთ ნაჩვენებია მარტივი არამიმართული გრაფი, რომელსაც აქვს 6 წვერო და 9 წიბო.",
        "interactionPrompt": "თქვენ შეგიძლიათ დააწკაპუნოთ და გადაადგილოთ წიბოები!"
      },
      "graphDirectedness": {
        "title": "არამიმართული და მიმართული გრაფები",
        "definition": "გრაფები შეიძლება დავყოთ ორ ჯგუფად: არამიმართული და მიმართული, მათი წიბოების ბუნების მიხედვით:",
        "undirected": {
          "label": "არამიმართული გრაფი",
          "description": "წიბოებს არ აქვთ მიმართულება. კავშირი წვეროებს შორის სიმეტრიულია."
        },
        "directed": {
          "label": "მიმართული გრაფი",
          "description": "წიბოებს აქვთ მიმართულება. კავშირი წვეროებს შორის შეიძლება იყოს ასიმეტრიული."
        },
        "selectedEdge": "არჩეული წიბო: {{edge}}",
        "prompt": "დააწკაპუნეთ გრაფის წიბოზე, რათა ნახოთ განსხვავება ვიზუალურად.",
        "interactionPrompt": "დააწკაპუნეთ წიბოებზე ორივე გრაფში, რათა შეადაროთ არამიმართული და მიმართული გრაფები!"
      },
      "verticesAndEdges": {
        "title": "წვეროები და წიბოები",
        "description": "გრაფი შედგება ორი მთავარი ელემენტისგან:",
        "vertices": {
          "label": "წვეროები",
          "description": "წერტილები ან წრეები გრაფში"
        },
        "edges": {
          "label": "წიბოები",
          "description": "წიბოები, რომლებიც აკავშირებს წვეროებს"
        },
        "explanation": "მაგალითი: წრეები არის წვეროები. ხაზები, რომლებიც აკავშირებს ამ წვეროებს, არის წიბოები. მიმართულ გრაფში (მარჯვნივ), წვეროებს აქვს ისრები, რომლებიც მიუთითებს მიმართულებას.",
        "interactionPrompt": "დააწკაპუნეთ \"წვეროებს\" ან \"წიბოებს\" ზემოთ, რათა აღიქვათ ისინი!",
        "undirectedGraph": "არამიმართული გრაფი",
        "directedGraph": "მიმართული გრაფი"
      },
      "vertexDegree": {
        "title": "წვეროს ხარისხი",
        "description": "წვეროს ხარისხი არის წიბოების რაოდენობა, რომლებიც მასთან არის დაკავშირებული. სხვა სიტყვებით, ეს არის მეზობლების რაოდენობა, რომლებიც წვეროს ჰყავს.",
        "undirectedGraphDescription": "არამიმართული გრაფებისთვის, ეს უბრალოდ წვეროსთან დაკავშირებული წიბოების რაოდენობაა.",
        "directedGraphDescription": "მიმართულ გრაფებში, ჩვენ განვასხვავებთ შემომავალი და გამავალი წიბოების რაოდენობას.",
        "undirectedGraph": "არამიმართული გრაფი",
        "directedGraph": "მიმართული გრაფი",
        "undirectedDegreeExplanation": "არამიმართულ გრაფში {{selectedNode}} წვეროს ხარისხი არის {{undirectedDegree}}.",
        "directedDegreeExplanation": "მიმართულ გრაფში {{selectedNode}} წვეროს აქვს {{inDegree}} შემომავალი და {{outDegree}} გამავალი წიბო.",
        "selectVertexPrompt": "დააჭირეთ წვეროს ორივე გრაფში, რათა იხილოთ მისი ხარისხი.",
        "interactionPrompt": "დააჭირეთ სხვადასხვა წვეროს ორივე გრაფში, რათა შეადაროთ წვეროების ხარისხი არამიმართულ და მიმართულ გრაფებში!"
      },
      "pathsAndCycles": {
        "title": "გზები და ციკლები გრაფებში",
        "description": "გრაფთა თეორიაში გზები და ციკლები საბაზისო ცნებებია: გზა არის წვეროების თანმიმდევრობა, რომლებიც დაკავშირებულია წიბოებით, ყოველგვარი გამეორების გარეშე. ციკლი არის გზა, რომელიც იწყება და მთავრდება ერთი და იმავე წვეროთი.",
        "pathExplanation": "ეს არის გზა: e → f → g → a → b → c → d: ერთმანეთთან დაკავშირებული წვეროების თანმიმდევრობა გამეორების გარეშე.",
        "cycleExplanation": "ეს არის ციკლი: a → b → c → f → g → a. ის იწყება და მთავრდება ერთიდაიმავე წვეროთი.",
        "showPathButton": "გზის ჩვენება",
        "showCycleButton": "ციკლის ჩვენება",
        "resetButton": "გადატვირთვა",
        "interactionPrompt": "დააწკაპუნეთ ღილაკებზე, რათა იხილოთ გზის და ციკლის მაგალითები."
      },
      "graphConnectivity": {
        "title": "კავშირი გრაფებში",
        "description": "კავშირი გრაფებში განსხვავდება იმის მიხედვით, არის თუ არა ყველა წვერო დაკავშირებული ერთმანეთთან. გრაფი არის ბმული, თუ არსებობს გზა ყოველ წყვილ წვეროს შორის.",
        "connectedGraph": "ბმული გრაფი",
        "disconnectedGraph": "არაბმული გრაფი",
        "connectedExplanation": "ამ ბმულ გრაფში შეგიძლიათ მიწვდეთ ნებისმიერ წვეროს ნებისმიერი სხვა წვეროდან.",
        "disconnectedExplanation": "ამ არაბმულ გრაფში ორი ცალკეული კომპონენტია. თქვენ ვერ იპოვით გზას C ან D-დან A ან B-მდე.",
        "additionalInfo": "ბმულ გრაფს აქვს მხოლოდ ერთი კომპონენტი, მაშინ როცა არაბმული გრაფს აქვს ორი ან მეტი კომპონენტი. კომპონენტები ისეთი ქვეგრაფებია, სადაც ყველა წვერო დაკავშირებულია ერთმანეთთან, მაგრამ არაა დაკავშირებული სხვა კომპონენტების წვეროებთან."
      },
      "subgraphs": {
        "title": "ქვეგრაფები",
        "description": "ქვეგრაფი არის გრაფი, რომლის წვეროებისა და წიბოების სიმრავლე სხვა გრაფის ქვესიმრავლეა. ეს არის დიდი გრაფის პატარა ნაწილი, რომელშიც შენარჩუნებულია იგივე კავშირები, რაც თავდაპირველ გრაფში იყო.",
        "fullGraphExplanation": "ეს არის სრული გრაფი. ქვეგრაფი არის წვეროებისა და წიბოების ნაკრები ამ გრაფიდან.",
        "triangleExplanation": "ეს სამკუთხედი (A-B-C) არის ქვეგრაფი. მას აქვს ზოგიერთი, მაგრამ არა ყველა თავდაპირველი გრაფის წვერო და წიბო.",
        "pathExplanation": "ეს გზა (B-C-D-E) ასევე არის ქვეგრაფი. ის არის დაკავშირებული წვეროების მიმდევრობა, რომელიც შედის უფრო დიდ გრაფში.",
        "showFullGraph": "მაჩვენე სრული გრაფი",
        "showTriangle": "მაჩვენე სამკუთხედის ფორმის ქვეგრაფი",
        "showPath": "მაჩვენე გზის ფორმის ქვეგრაფი",
        "resetButton": "გადატვირთვა"
      }
    },
    "differentGraphs": {
      "title": "სხვადასხვა ტიპის გრაფები",
      "planarGraphs": {
        "planarTitle": "ბრტყელი გრაფები",
        "planarDescription": "ბრტყელი გრაფი არის ისეთი გრაფი, რომელიც სიბრტყეზე ისე შეიძლება დაიხატოს, რომ მისი წიბოები არსად გადაიკვეთოს, მხოლოდ წვეროსთან. ეს ნიშნავს, რომ წიბოები მხოლოდ მათი ბოლოებით ეხებიან ერთმანეთს.",
        "planarLabel": "ბრტყელი გრაფი",
        "nonPlanarLabel": "არაბრტყელი გრაფი",
        "planarInteractionPrompt": "შეცვალეთ წვეროების რაოდენობა და დააკვირდით როგორ იცვლება ბრტყელი და არაბრტყელი გრაფების ვიზუალი.",
        "numberOfNodes": "წვეროების რაოდენობა"
      },
      "weightedGraphs": {
        "title": "წონიანი გრაფები",
        "introduction": "წონიანი გრაფები გამოიყენება ქსელების გამოსახატავად, სადაც კიდეებს აქვთ წონები ან ხარჯები.",
        "definition": {
          "title": "განსაზღვრა",
          "description": "წონიან გრაფებში თითოეული კიდე აქვს წონა, რაც აღნიშნავს ხარჯს ან მანძილს ქულებს შორის."
        },
        "explanation": "მაგალითური გრაფში თითოეული კიდის წონა ნიშნულია. ეს ეხმარება აჩვენოს ქულების შორის განლაგების ან ხარჯების ურთიერთმოწვდომა."
      }
    },
    "graphProblems": {
      "title": "გრაფთა თეორიის ამოცანები"
    }
  }
}
