{
  "title": "მათემატიკა კომპიუტერული მეცნიერებისთვის",
  "courses": "კურსები",
  "signIn": "შესვლა",
  "signOut": "გასვლა",
  "register": "რეგისტრაცია",
  "introduction_to_logical_operators_title": "შესავალი: ლოგიკური ოპერატორები",
  "calculate": "გამოთვლა",
  "binarySystemTitle": "ორობითი სისტემა",
  "logicalOperandsTitle": "ლოგიკური ოპერატორები",
  "graphTheoryTitle": "გრაფთა თეორია",
  "numberTheoryTitle": "რიცხვთა თეორია",
  "introduction": "შესავალი",
  "lcm-gcd": "უ.ს.ჯ და უ.ს.გ",
  "rsa-algorithm": "RSA ალგორითმი",
  "modular-arithmetic": "მოდულარული არითმეტიკა",
  "quizResults": "ქვიზის შედეგები",
  "question": "შეკითხვა",
  "yourAnswer": "თქვენი პასუხი",
  "correctAnswer": "სწორი პასუხი",
  "totalScore": "ჯამური ქულა",
  "tryAgain": "თავიდან ცდა",
  "correct": "სწორია",
  "incorrect": "არასწორია!",
  "decimalValue": "ათობითი მნიშვნელობა",
  "converting": "კონვერტაცია",
  "binaryRepresentation": "ორობითი რეპრეზენტაცია",
  "binaryArithmetic": "ორობითი არითმეტიკა",
  "clickToExplore": "დააწკაპუნეთ, რომ გაეცნოთ კურსს",
  "welcome": "მოგესალმებით",
  "complete": "შესრულებული",
  "result": "შედეგი",
  "wantToTakeQuiz": "გსურთ, რომ შეავსოთ ქვიზი?",
  "wantToSolveProblems": "გსურთ, რომ ამოხსნათ ამოცანები?",
  "viewResults": "შედეგების ნახვა",
  "red": "წითელი",
  "green": "მწვანე",
  "blue": "ლურჯი",
  "binaryColorMixer": "ორობითი ფერების მიქსინგი",
  "hours": "საათი",
  "minutes": "წუთი",
  "seconds": "წამი",
  "currentTime": "მიმდინარე დრო",
  "example": "მაგალითი",
  "binaryConversionGame": "ორობითი კონვერტაციის თამაში",
  "startGame": "თამაშის დაწყება",
  "convertToDecimal": "გადაიყვანეთ ათობითში",
  "convertToBinary": "გადაიყვანეთ ორობითში",
  "score": "ქულა",
  "timeLeft": "დარჩენილი დრო",
  "secondsShort": "წმ",
  "submit": "დადასტურება",
  "binaryNumber": "ორობითი რიცხვი",
  "enterOnesAndZeros": "შეიყვანეთ 1-ები და 0-ები",
  "chooseCourse": "აირჩიეთ თქვენთვის სასურველი კურსი",
  "completed": "შესრულებული",
  "easy": "მარტივი",
  "medium": "საშუალო",
  "hard": "რთული",
  "problemCompletion": "შესრულებული ამოცანები",
  "binaryProblems": "ორობითი სისტემის ამოცანები",
  "numberTheoryProblems": "რიცხვთა თეორიის ამოცანები",
  "problems": {
    "selectProblem": "აირჩიეთ ამოცანა",
    "description": "აღწერა:",
    "difficulty": "სირთულე:",
    "task": "დავალება:",
    "inputFormat": "შემომავალი მონაცემების ფორმატი:",
    "outputFormat": "დასაბრუნებელი მონაცემების ფორმატი:",
    "example": "მაგალითი:",
    "note": "შენიშვნა:",
    "chooseLanguage": "აირჩიეთ ენა",
    "language": "ენა",
    "runCode": "გაუშვი კოდი",
    "running": "მიმდინარეობს...",
    "output": "შედეგი:",
    "testCase": "ტესტი",
    "testCaseSuccessful": "წარმატებულია",
    "testCaseFailed": "არაწარმატებულია",
    "expectedResult": "სასურველი შედეგი",
    "gotResult": "ამოხსნის შედეგი",
    "codeAndTestsRunning": "მიმდინარეობს კოდისა და ტესტების გაშვება..."
  },
  "binarySystem": {
    "introduction": {
      "title": "შესავალი ორობით სისტემაში",
      "welcome": "მოგესალმებით ორობითი სისტემის სამყაროში! ჩვენს ყოველდღიურ ჩვენ მიჩვეულები ვართ ათობით სისტემასთან მუშაობას, რომელიც იყენებს ათ ციფრს (0-9). მაგრამ იცოდით თუ არა, რომ კომპიუტერის გულში დევს გაცილებით მარტივი სისტემა, რომელიც იყენებს მხოლოდ ორ ციფრს: 0 და 1? ეს არის ორობითი სისტემა და ის არის ყველა ციფრული გამოთვლის საფუძველი.",
      "whatIs": {
        "title": "რა არის ორობითი სისტემა?",
        "description": "ორობითი სისტემა, ასევე ცნობილი როგორც ორის ფუძიანი (base-2) რიცხვთა სისტემა, არის მათემატიკური გამოსახულების მეთოდი, რომელიც იყენებს მხოლოდ ორ სიმბოლოს: 0 და 1. ამ ციფრებიდან თითოეულს ეწოდება 'ბიტი' (binary digit-ის შემოკლებული ფორმა)."
      },
      "whyImportant": {
        "title": "რატომ არის ის მნიშვნელოვანი?",
        "description": "ორობითი სისტემა მნიშვნელოვანია გამოთვლებისთვის რამდენიმე მიზეზის გამო:",
        "points": [
          "სიმარტივე: მხოლოდ ორი მდგომარეობით, ორობითი სისტემა იდეალურია ისეთი მდგომარეობების გამოსახატავად, როგორიცაა ჩართული/გამორთული, ჭეშმარიტი/მცდარი ან დიახ/არა.",
          "ელექტრონული იმპლემენტაცია: ადვილია ორობითი ციფრების წარმოდგენა ელექტრული სიგნალების გამოყენებით - ჩართული 1-ისთვის, გამორთული 0-სთვის.",
          "შეცდომების აღმოჩენა: ორობითი სისტემა ამარტივებს შეცდომების აღმოჩენასა და გასწორებას მონაცემთა გადაცემისას.",
          "გამოთვლების საფუძველი: ყველა მონაცემი კომპიუტერებში - ტექსტი, სურათები, ვიდეოები და თვით ინსტრუქციები, რომლებიც კომპიუტერს ეუბნებიან რა გააკეთოს - საბოლოოდ ინახება და მუშავდება ორობით ფორმატში."
        ]
      },
      "realLifeExamples": {
        "title": "ორობითი სისტემის მაგალითები რეალურ ცხოვრებაში",
        "description": "ორობითი სისტემა არ არის მხოლოდ თეორიული კონცეფცია - ის ჩვენს გარშემოა ყოველდღიურ ცხოვრებაში! აი რამდენიმე მაგალითი:",
        "points": [
          "ციფრული ფოტოგრაფია: როდესაც იღებთ ფოტოს ციფრული კამერით ან სმარტფონით, სურათი ინახება ორობითი რიცხვების სახით.",
          "მუსიკის სტრიმინგი: როდესაც უსმენთ მუსიკას Spotify-ზე ან Apple Music-ზე, სინამდვილეში თქვენ ისმენთ ორობით მონაცემებს, რომლებიც გარდაქმნილია ბგერის ტალღებად.",
          "მორზეს კოდი: მიუხედავად იმისა, რომ მკაცრად ორობითი არ არის, მორზეს კოდი არის ახლო ანალოგი, რომელიც იყენებს წერტილებსა და ტირეებს ასოებისა და რიცხვების კოდირებისთვის.",
          "კომპიუტერის ეკრანები: თქვენი კომპიუტერის ან ტელეფონის ეკრანზე თითოეული პიქსელი განისაზვრება ორობითი მონაცემებით, რაც ქმნის ფერების სრულ სპექტრს, რომელსაც ხედავთ."
        ]
      },
      "conclusion": "როდესაც უფრო ჩაუღრმავდებით კომპიუტერულ მეცნიერებას, აღმოაჩენთ, რომ ორობითი სისტემის გაგება მნიშვნელოვანია ისეთი თემებისთვის, როგორიცაა ციფრული ლოგიკა, კომპიუტერის არქიტექტურა და მონაცემთა წარმოდგენა. ეს რეალური ცხოვრების მაგალითები გვიჩვენებს, თუ როგორ უდევს საფუძვლად ეს მარტივი 0-ებისა და 1-ების სისტემა ჩვენი თანამედროვე, ციფრული სამყაროს დიდ ნაწილს. მაშ ასე, დავიწყოთ ეს ორობითი თავგადასავალი ერთად!"
    },
    "representation": {
      "title": "ორობითი რიცხვების წარმოდგენა",
      "description": "ორობითი არის კომპიუტერების ენა, რომელიც იყენებს მხოლოდ ორ ციფრს: 0 და 1. შევისწავლოთ, როგორ შეუძლია ამ მარტივ სისტემას წარმოადგინოს რთული ინფორმაცია.",
      "placeValue": {
        "title": "პოზიციური მნიშვნელობა ორობით სისტემაში",
        "description": "ორობით სისტემაში თითოეული პოზიცია წარმოადგენს 2-ის ხარისხს, მსგავსად იმისა, როგორც ათობითი სისტემა იყენებს 10-ის ხარისხებს.",
        "table": {
          "position": "პოზიცია",
          "value": "მნიშვნელობა"
        }
      },
      "patterns": {
        "title": "ორობითი პატერნები და თვისებები",
        "description": "ორობით სისტემაში პატერნების ამოცნობა დაგეხმარებათ მათ გაგებასა და გამოყენებაში:",
        "examples": [
          "რიცხვი, რომელშიც ყველა ციფრი 1-იანია: წარმოადგენს 2ⁿ - 1-ს (მაგ. 1111 = 15)",
          "რიცხვი, რომელშიც პირველი ციფრია 1 და დანარჩენი 0-ები: 2-ის ხარისხები (მაგ. 1000 = 8)"
        ]
      },
      "binaryInColors": {
        "title": "ორობითი რიცხვები ფერებში",
        "description": "RGB ფერები იყენებს ორობით სისტემას მილიონობით ფერის წარმოსადგენად. ჩაატარეთ ექსპერიმენტი, რომ ნახოთ როგორ ქმნის ორობითი სისტემა ფერებს:"
      },
      "binaryClock": {
        "title": "ორობითი საათი",
        "description": "ორობითი საათი იყენებს ორობით რიცხვთა სისტემას დროის საჩვენებლად. შეგიძლიათ ქვემოთ ნაჩვენები დროის ამოცნობა?"
      }
    },
    "conversion": {
      "title": "ორობით-ათობითი კონვერტაცია",
      "description": "ორობითსა და ათობითს შორის კონვერტაცია ფუნდამენტია კომპიუტერულ მეცნიერებაში. შევისწავლოთ სხვადასხვა მეთოდი და ვივარჯიშოთ კონვერტაციაში.",
      "decimalToBinary": {
        "title": "ათობითიდან ორობითში კონვერტაცია",
        "description": "ათობითიდან ორობითში კონვერტაციისთვის შეგვიძლია გამოვიყენოთ 2-ზე გაყოფის მეთოდი:",
        "example": "გადავიყვანოთ 25 ორობითში\n25 ÷ 2 = 12 ნაშთი 1\n12 ÷ 2 = 6 ნაშთი 0\n6 ÷ 2 = 3 ნაშთი 0\n3 ÷ 2 = 1 ნაშთი 1\n1 ÷ 2 = 0 ნაშთი 1\nნაშთების წაკითხვა ქვემოდან ზემოთ: 25 = 11001"
      },
      "binaryToDecimal": {
        "title": "ორობითიდან ათობითში კონვერტაცია",
        "description": "ორობითიდან ათობითში კონვერტაციისთვის, ვამრავლებთ თითოეულ ციფრს მის ადგილობრივ მნიშვნელობაზე და ვაჯამებთ შედეგებს:",
        "example": "გადავიყვანოთ 11001 ათობითში\n1 × 2^4 + 1 × 2^3 + 0 × 2^2 + 0 × 2^1 + 1 × 2^0\n= 16 + 8 + 0 + 0 + 1\n= 25"
      },
      "shortcutMethods": {
        "title": "სწრაფი მეთოდები",
        "description": "რამდენიმე სწრაფი ხერხი ორობით-ათობითი კონვერტაციისთვის:",
        "methods": [
          "2-ის ხარისხებისთვის, ორობითი ფორმა არის 1, რომელსაც მოსდევს შესაბამისი რაოდენობის ნულები",
          "ორობითი რიცხვის გასაორმაგებლად, მას მარჯვინ მიაწერეთ 0",
          "ლუწი ორობითი რიცხვის გასანახევრებლად, წაშალეთ უკიდურესი მარჯვენა 0"
        ]
      },
      "conversionTable": {
        "title": "ორობით-ათობითი კონვერტაციის ცხრილი",
        "description": "ეს ცხრილი გვიჩვენებს ორობით ექვივალენტებს ათობითი რიცხვებისთვის 0-დან 15-მდე:",
        "decimal": "ათობითი",
        "binary": "ორობითი"
      },
      "converter": {
        "title": "კონვერტაციის ხელსაწყო",
        "description": "გამოიყენეთ ეს ინსტრუმენტი ორობითსა და ათობითს შორის კონვერტაციისთვის."
      },
      "game": {
        "title": "ორობითი კონვერტაციის თამაში",
        "description": "გამოსცადეთ თქვენი კონვერტაციის უნარები ამ სახალისო თამაშით! წარმოადგინეთ საპირისპირო სისტემაში რაც შეიძლება მეტი რიცხვი 60 წამში:"
      },
      "calculator": {
        "binary": "ორობითი",
        "decimal": "ათობითი",
        "enterBinaryNumber": "შეიყვანეთ ორობითი რიცხვი",
        "enterDecimalNumber": "შეიყვანეთ ათობითი რიცხვი"
      },
      "flowchart": {
        "decimalToBinaryTitle": "ათობითიდან ორობითში კონვერტაცია",
        "binaryToDecimalTitle": "ორობითიდან ათობითში კონვერტაცია",
        "decimalToBinary": [
          "აიღეთ ათობითი რიცხვი",
          "↓",
          "გაყავით 2-ზე",
          "↓",
          "დაიმახსოვრეთ ნაშთი (0 ან 1)",
          "↓",
          "გააგრძელეთ განაყოფის გაყოფა 2-ზე",
          "↓",
          "შეწყვიტეთ, როცა განაყოფი გახდება 0",
          "↓",
          "წაიკითხეთ ნაშთები ქვემოდან ზემოთ"
        ],
        "binaryToDecimal": [
          "აიღეთ ორობითი რიცხვი",
          "↓",
          "გაამრავლეთ თითოეული ციფრი 2-ის ხარისხზე",
          "↓",
          "შეაჯამეთ ყველა ნამრავლი",
          "↓",
          "შედეგი არის ათობითი რიცხვი"
        ]
      }
    },
    "arithmetic": {
      "title": "ორობითი არითმეტიკა",
      "description": "ორობითი არითმეტიკა გულისხმობს მათემატიკური ოპერაციების შესრულებას მხოლოდ ორი ციფრის გამოყენებით: 0 და 1.",
      "addition": {
        "title": "ორობითი შეკრება",
        "description": "ორობითი შეკრება მსგავსია ათობითი შეკრების. ვიწყებთ უკიდურესი მარჯვენა სვეტიდან და ვიმახსოვრებთ ნაშთს, როცა ჯამი აღემატება 1-ს.",
        "example": "  1 1 0 1\n+ 1 0 1 1\n  -------\n1 1 0 0 0"
      },
      "subtraction": {
        "title": "ორობითი გამოკლება",
        "description": "ორობითი გამოკლებაც მიჰყვება მსგავს წესებს, რასაც ათობითი გამოკლება. როცა გვჭირდება რომ ვისესხოთ, ვსესხულობთ იმ სვეტის მარცხენა მეზობლისგან, სადაც ვიმყოფებით.",
        "example": "  1 1 0 1\n- 1 0 1 1\n  -------\n  0 0 1 0"
      },
      "multiplication": {
        "title": "ორობითი გამრავლება",
        "description": "ორობითი გამრავლება არის შეკრებების სერია. ვამრავლებთ ერთი რიცხვის თითოეულ ციფრს მეორე რიცხვზე, თითოეულ ჯერზე მარცხნივ ერთი ნაბიჯის გადაგმით.",
        "example": "        1 1 0 1\n      ×   1 0 1\n        -------\n        1 1 0 1\n      0 0 0 0\n    1 1 0 1\n        -------\n  1 0 0 0 0 0 1"
      },
      "division": {
        "title": "ორობითი გაყოფა",
        "description": "ორობითი გაყოფაც ასევე მსგავსია ათობითი გაყოფის. განმეორებითად ვასრულებთ გამოკლებას და ჩამოგვაქვს ციფრები საჭიროებისამებრ.",
        "example": "1 1 0 1 | 1 0\n1 0     -------\n---     1 1 0  (ნაშთი 1)\n  1 0\n  1 0\n  ---\n    0 1\n      0\n    ---\n      1"
      },
      "twoComplement": {
        "title": "Two's Complement",
        "description": "Two's Complement არის მეთოდი ორობით სისტემაში დადებითი და უარყოფითი რიცხვების წარმოსადგენად. ის ფართოდ გამოიყენება კომპიუტერულ სისტემებში გამოკლების დროს და უარყოფითი რიცხვების წარმოსადგენად.",
        "steps": [
          "შეაბრუნეთ ყველა ბიტი (შეცვალეთ 0 1-ით და 1 0-ით)",
          "შედეგს მიუმატეთ 1"
        ],
        "example": "-5 8-ბიტიან Two's Complement-ში\n1. დადებითი 5:  0000 0101\n2. შეაბრუნეთ ბიტები: 1111 1010\n3. მიუმატეთ 1:   1111 1011\nამრიგად, -5 Two-s Complement-ში არის 1111 1011"
      },
      "applications": {
        "title": "ორობითი არითმეტიკის გამოყენებები",
        "description": "ორობით არითმეტიკას ძალიან დიდი როლი აქვს კომპიუტერის მიერ ინფორმაციის დამუშავების პროცესში. აი, რამდენიმე რეალური გამოყენება:",
        "examples": [
          "ციფრული სიგნალების დამუშავება: გამოიყენება აუდიო და ვიდეო კომპრესიაში",
          "კრიპტოგრაფია: უსაფრთხო შეტყობინებების კოდირებისა და დეკოდირებისთვის",
          "შეცდომების გასწორება: მონაცემთა გადაცემასა და შენახვაში",
          "კომპიუტერული გრაფიკა: გამოსახულებებისა და ანიმაციების რენდერინგისთვის",
          "ხელოვნური ინტელექტი: ნეირონული ქსელების გამოთვლებში"
        ]
      },
      "calculator": {
        "title": "ორობითი კალკულატორი",
        "description": "ივარჯიშეთ ორობითი არითმეტიკული ოპერაციები ამ ინტერაქტიული კალკულატორით:"
      }
    },
    "binaryArithmetic": {
      "title": "გაღრმავებული ორობითი არითმეტიკა",
      "introduction": "ორობითი არითმეტიკა მუშაობს ათობითი არითმეტიკის მსგავსად, მაგრამ მიჰყვება ორობითი რიცხვითი სისტემის წესებს. ამ ოპერაციების გაგება მნიშვნელოვანია დაბალი დონის პროგრამირებისა და კომპიუტერის არქიტექტურისთვის.",
      "addition": {
        "title": "ორობითი შეკრება",
        "description": "ორობითი შეკრება ათობითი შეკრების მსგავსია, მაგრამ მხოლოდ ორი ციფრით. მთავარია გვახსოვდეს, რომ 1 + 1 ორობითში უდრის 10-ს (2-ს ათობითში).",
        "table": [
          {
            "A": "0",
            "B": "0",
            "ჯამი": "0",
            "გადატანა": "0"
          },
          {
            "A": "0",
            "B": "1",
            "ჯამი": "1",
            "გადატანა": "0"
          },
          {
            "A": "1",
            "B": "0",
            "ჯამი": "1",
            "გადატანა": "0"
          },
          {
            "A": "1",
            "B": "1",
            "ჯამი": "0",
            "გადატანა": "1"
          }
        ],
        "example": "მაგალითი: 1011-ისა და 1101-ის შეკრება\n  1011\n+ 1101\n------\n 10100"
      },
      "subtraction": {
        "title": "ორობითი გამოკლება",
        "description": "ორობითი გამოკლება მიჰყვება ათობითი გამოკლების მსგავს პრინციპებს, საჭიროების შემთხვევაში სესხებით.",
        "table": [
          {
            "A": "0",
            "B": "0",
            "სხვაობა": "0",
            "სესხი": "0"
          },
          {
            "A": "0",
            "B": "1",
            "სხვაობა": "1",
            "სესხი": "1"
          },
          {
            "A": "1",
            "B": "0",
            "სხვაობა": "1",
            "სესხი": "0"
          },
          {
            "A": "1",
            "B": "1",
            "სხვაობა": "0",
            "სესხი": "0"
          }
        ],
        "example": "მაგალითი: 1011-ის გამოკლება 1101-დან\n  1101\n- 1011\n------\n  0010"
      },
      "multiplication": {
        "title": "ორობითი გამრავლება",
        "description": "ორობითი გამრავლება უფრო მარტივია ვიდრე ათობითი გამრავლება, რადგან მხოლოდ 0-ებსა და 1-ებს მოიცავს.",
        "table": [
          {
            "A": "0",
            "B": "0",
            "ნამრავლი": "0"
          },
          {
            "A": "0",
            "B": "1",
            "ნამრავლი": "0"
          },
          {
            "A": "1",
            "B": "0",
            "ნამრავლი": "0"
          },
          {
            "A": "1",
            "B": "1",
            "ნამრავლი": "1"
          }
        ],
        "example": "მაგალითი: 101-ის გამრავლება 11-ზე\n  101\n×  11\n-----\n  101\n 101\n-----\n 1111"
      },
      "division": {
        "title": "ორობითი გაყოფა",
        "description": "ორობითი გაყოფა მიჰყვება ათობითი გაყოფის იმავე პრინციპებს, მაგრამ იყენებს ორობით რიცხვებს.",
        "example": "მაგალითი: 1010-ის გაყოფა 10-ზე\n  101\n-------\n10 | 1010\n    - 10\n    ----\n      10\n     -10\n    ----\n       0"
      },
      "advancedTopics": {
        "title": "გაღრმავებული ორობითი არითმეტიკის კონცეფციები",
        "description": "ძირითადი ოპერაციების გარდა, არსებობს რამდენიმე გაღრმავებული თემა ორობით არითმეტიკაში:",
        "list": [
          "ორის შევსების წარმოდგენა ნიშნიანი მთელი რიცხვებისთვის",
          "ათწილადი რიცხვების არითმეტიკა (IEEE 754 სტანდარტი)",
          "ბიტური ოპერაციები (AND, OR, XOR, NOT)",
          "არითმეტიკული და ლოგიკური წანაცვლებები",
          "მიმდევრობითი გადატანის შემკრები და სხვა სწრაფი შეკრების ტექნიკები",
          "ბუთის გამრავლების ალგორითმი",
          "არააღდგენითი გაყოფის ალგორითმი"
        ]
      },
      "applications": {
        "title": "ორობითი არითმეტიკის გამოყენებები",
        "description": "ორობითი არითმეტიკა ფუნდამენტურია კომპიუტინგის მრავალ სფეროში:",
        "list": [
          "ALU-ს (არითმეტიკულ-ლოგიკური მოწყობილობა) დიზაინი პროცესორებში",
          "ათწილადების თანაპროცესორები",
          "ციფრული სიგნალების დამუშავება",
          "კრიპტოგრაფიული ალგორითმები",
          "შეცდომების აღმოჩენისა და გასწორების კოდები",
          "კომპიუტერული გრაფიკა (მაგ., მატრიცული ოპერაციები)",
          "მანქანური სწავლების აქსელერატორები"
        ]
      },
      "calculator": {
        "enterFirstBinary": "შეიყვანეთ პირველი ორობითი რიცხვი",
        "enterSecondBinary": "შეიყვანეთ მეორე ორობითი რიცხვი"
      }
    }
  },
  "logicalOperands": {
    "title": "ლოგიკური ოპერატორები",
    "introduction": {
      "title": "შესავალი",
      "description": "ლოგიკური ოპერატორები ფუნდამენტური თემაა დისკრეტულ მათემატიკასა და კომპიუტერულ მეცნიერებებში. მათი გამოყენება საშუალებას გვაძლევენ ავაგოთ რთული პირობები და განვსაზღვროთ გადაწყვეტილებები პროგრამაში მიმდინარე პროცესებში.",
      "moduleExploration": {
        "header": "ამ კურსში, თქვენ გაეცნობით შემდეგ თემებს:",
        "items": [
          "მარტივი ლოგიკური ოპერატორები",
          "რთული ლოგიკური ოპერატორები",
          "ჭეშმარიტების ცხრილები"
        ]
      },
      "understandingImportance": {
        "header": "ლოგიკური ოპერატორების მნიშვნელობა",
        "items": [
          "ისინი აუცილებელია პროგრამირებაში პირობების განსაზღვრისა და პროგრამის მიმდინარეობის კონტროლისათვის.",
          "ისინი წარმოადგენენ კომპიუტერული სქემების დიზაინის საფუძველს.",
          "ისინი ფართოდ გამოიყენება მონაცემთა ბაზებზე კომპლექსური ძიების გასაშვებად.",
          "ისინი მნიშვნელოვან როლს ასრულებენ ხელოვნური ინტელექტის სისტემებში, განსაკუთრებით გადაწყვეტილების მიღების ალგორითმებში."
        ]
      },
      "realLifeExamples": {
        "header": "ლოგიკური ოპერატორები ყოველდღიურ ცხოვრებაში",
        "description": "ლოგიკური ოპერატორების თემა არ არის მხოლოდ კომპიუტერული ცნება. ის გვხვდება ჩვენს ყოველდღიურ გადაწყვეტილებებშიც. მოდით, განვიხილოთ მარტივი მაგალითი ნათურის ჩამრთველებით:",
        "lightSwitchExample": {
          "title": "ნათურის ჩამრთველების მაგალითი",
          "description": "წარმოიდგინეთ, რომ გაქვთ ოთახი ორი ჩამრთველით. თითოეული ჩამრთველი შეიძლება იყოს ჩართული ან გამორთული. შემოვიტანოთ ორი ლოგიკური ოპერატორი: და, ან. განვიხილოთ ისინი მაგალითებით.",
          "andOperatorName": "და",
          "andOperator": " - ნათურა აინთება მხოლოდ მაშინ, როცა ორივე ჩამრთველი ჩართულია.",
          "orOperatorName": "ან",
          "orOperator": " - ნათურა აინთება, თუ ერთ-ერთი ჩამრთველი მაინც ჩართულია."
        }
      },
      "progressNote": "ამ კურსში წინსვლისას, თქვენ მოიპოვებთ მყარ ცოდნას ლოგიკური ოპერატორების მიმართულებით, რაც მოგამზადებთ კომპიუტერულ მეცნიერებასა და დისკრეტულ მათემატიკაში უფრო რთული თემებისთვის."
    },
    "basicOperators": {
      "title": "მარტივი ლოგიკური ოპერატორები",
      "introduction": "მოგესალმებით ლოგიკური ოპერატორების სამყაროში! ისინი გადაწყვეტილების მიღების საფუძველია როგორც პროგრამირებაში, ასევე ყოველდღიურ ცხოვრებაში. როგორც შუქნიშნები მართავენ მანქანების მოძრაობას გზაზე, ასევე ლოგიკური ოპერატორები მართავენ ჩვენი პროგრამების მუშაობის მიმდინარეობას. ისინი გვეხმარებიან მივიღოთ გადაწყვეტილებები სხვადასხვა პირობების საფუძველზე, რაც საშუალებას აძლევს ჩვენს კოდს \"იფიქროს\" და \"იმოქმედოს\". მოდით ვნახოთ, როგორ აყალიბებენ მარტივი ლოგიკური ოპერატორები ჩვენს გარშემო არსებულ ციფრულ სამყაროს!",
      "interactionPrompt": "მოდით, ვცადოთ! დააწკაპუნეთ ქვემოთ მოცემულ ბიტებზე 0-სა (მცდარი) და 1-ს (ჭეშმარიტი) შორის გადასართველად. დააკვირდით, როგორ რეაგირებს თითოეული ოპერატორი თქვენს არჩევანზე!",
      "and": {
        "title": "და: პერფექციონისტი",
        "description": "\"და\" ოპერატორი მკაცრ მასწავლებელს ჰგავს - ის მხოლოდ მაშინ გაძლევთ დადებით შეფასებას (აბრუნებს ჭეშმარიტს ან 1-ს), როცა ყველა პირობა შესრულებულია. თუ რომელიმე პირობა ვერ სრულდება, შედეგი უარყოფითია (მცდარი ან 0).",
        "explanation": "წარმოიდგინეთ, რომ იდეალურ პიკნიკს გეგმავთ. თქვენ წახვალთ მხოლოდ იმ შემთხვევაში, თუ მზიანი ამინდია \"და\" თქვენ გაქვთ თავისუფალი დრო \"და\" თქვენი კალათა სავსეა საგზლით. \"და\" ოპერატორი პროგრამირებაში იგივე პრინციპით მუშაობს. ის ამოწმებს, არის თუ არა ყველა პირობა ჭეშმარიტი, ისევე როგორც თქვენ ამოწმებთ თქვენი პიკნიკისთვის სიის ყველა პუნქტს. ეს იდეალურია ისეთი სიტუაციებისთვის, სადაც ყველა პირობა ზუსტად უნდა დაემთხვეს!",
        "symbol": "&&"
      },
      "or": {
        "title": "ან: მოქნილი მეგობარი",
        "description": "\"ან\" ოპერატორი ლმობიერ მშობელს ჰგავს - თუ რომელიმე პირობა მაინც სრულდება (ჭეშმარიტია ან 1), ის კმაყოფილებას გამოხატავს. ის მხოლოდ მაშინ აბრუნებს მცდარს (0), როცა არცერთი პირობა არ სრულდება.",
        "explanation": "წარმოიდგინეთ \"ან\", როგორც თქვენი შაბათ-კვირის გეგმები. თქვენ კმაყოფილი იქნებით, თუ შეძლებთ ფილმის ყურებას \"ან\" მეგობრებთან ერთად დროის გატარებას \"ან\" კარგი წიგნის წაკითხვას. ნებისმიერი მათგანი კარგი დროის გატარებაა! პროგრამირებაში \"ან\" გვეხმარება შევქმნათ მოქნილი პირობები. ის შესანიშნავია, როდესაც გვაქვს რამდენიმე მისაღები ვარიანტი და ნებისმიერი მათგანი საკმარისია პროგრამის გასაგრძელებლად.",
        "symbol": "||"
      },
      "not": {
        "title": "არა: მეამბოხე",
        "description": "\"არა\" ოპერატორი ამ ჯგუფის მეამბოხეა - ის ყოველთვის საპირისპიროს აკეთებს. ის ჭეშმარიტს აქცევს მცდარად და მცდარს - ჭეშმარიტად.",
        "explanation": "წარმოიდგინეთ ცელქი და-ძმა, რომელიც ყოველთვის საწინააღმდეგოს აკეთებს იმისა, რასაც ეუბნებით. თუ ეტყვით 'არ შეეხო ამას', ისინი აუცილებლად შეეხებიან. ზუსტად ასე მუშაობს \"არა\" ოპერატორი. ეს ძალიან სასარგებლოა, როდესაც გინდათ შეამოწმოთ, რომ რაღაც არ არის ჭეშმარიტი. მაგალითად, იმის შემოწმება, რომ მომხმარებელი არ არის შესული სისტემაში, რათა აჩვენოთ მას შესვლის ღილაკი. \"არა\" გვეხმარება ჩვენი ლოგიკა თავდაყირა დავაყენოთ, როცა ეს გვჭირდება!",
        "symbol": "!"
      },
      "truthTables": {
        "title": "ჭეშმარიტების ცხრილი",
        "tableHeaderA": "პირობა A",
        "tableHeaderB": "პირობა B",
        "tableHeaderResult": "საბოლოო შედეგი"
      },
      "logicalOperatorGame": {
        "title": "ლოგიკური ოპერატორების თამაში",
        "introduction": "შეამოწმეთ თქვენი უნარები „და“, „ან“ და „არა“ ოპერატორების გარშემო. რამდენ სწორ პასუხს დააგროვებთ 30 წამში?",
        "time": "დრო",
        "score": "ქულა",
        "gameOver": "თამაში დასრულებულია!",
        "finalScore": "საბოლოო ქულა",
        "startGame": "თამაშის დაწყება",
        "playAgain": "სცადე თავიდან",
        "true": "ჭეშმარიტი",
        "false": "მცდარი"
      }
    },
    "advancedOperators": {
      "title": "რთული ლოგიკური ოპერატორები",
      "introduction": "მოგესალმებით რთული ლოგიკური ოპერატორების სამყაროში! ისინი ეფუძნებიან ძირითად ოპერატორებს და ქმნიან უფრო კომპლექსურ გადაწყვეტილების მიღების სტრუქტურებს პროგრამირებაში. როგორც შეფ-მზარეულები აერთიანებენ ინგრედიენტებს, ეს ოპერატორები ურევენ ძირითად ლოგიკურ ოპერატორებს რთული შედეგების მისაღებად. მოდით, ვნახოთ, როგორ ამდიდრებენ ისინი ჩვენს ლოგიკურ სამყაროს!",
      "interactionPrompt": "მოდით, ვცადოთ! დააწკაპუნეთ ქვემოთ მოცემულ ბიტებზე 0-სა (მცდარი) და 1-ს (ჭეშმარიტი) შორის გადასართველად. დააკვირდით, როგორ ამუშავებს თითოეული ოპერატორი თქვენს შეყვანილ მონაცემებს!",
      "nand": {
        "title": "NAND: უნივერსალური უარმყოფელი",
        "description": "NAND ოპერატორი ჰგავს ოპოზიციონერთა კომიტეტს - ის მხოლოდ მაშინ აბრუნებს მცდარს, როცა ყველა პირობა ჭეშმარიტია. ყველა სხვა შემთხვევაში ის აბრუნებს ჭეშმარიტს.",
        "explanation": "წარმოიდგინეთ მეგობრების ჯგუფი, რომელიც ფილმის არჩევანზე მსჯელობს. NAND-ით, თქვენ მხოლოდ მაშინ დარჩებით სახლში, თუ ყველა ერთსა და იმავე ფილმზე შეთანხმდება. ნებისმიერი უთანხმოება და თქვენ ფილმის სანახავად წახვალთ! ელექტრულ სქემებში NAND განსაკუთრებულია, რადგან მისი გამოყენებით შესაძლებელია ყველა სხვა ლოგიკური ოპერაციის შექმნა, რაც მას მრავალმხრივ სამშენებლო ბლოკად აქცევს.",
        "symbol": "⊼"
      },
      "nor": {
        "title": "NOR: უნივერსალური პესიმისტი",
        "description": "NOR ოპერატორი ჰგავს უკიდურეს კრიტიკოსს - ის მხოლოდ მაშინ აბრუნებს ჭეშმარიტს, როცა ყველა პირობა მცდარია. თუ რომელიმე პირობა ჭეშმარიტია, ის აბრუნებს მცდარს.",
        "explanation": "წარმოიდგინეთ NOR, როგორც გულფიცხი მჭამელი კაფეტერიაში. ის მხოლოდ მაშინ იქნება კმაყოფილი (დააბრუნებენ ჭეშმარიტს), თუ არცერთი კერძი არ მოეწონებათ. თუ თუნდაც ერთი კერძი კარგად გამოიყურება, ისინი უკმაყოფილონი არიან. ციფრულ ლოგიკაში NOR ოპერატორი განსაკუთრებულია, რადგან NAND-ის მსგავსად, მისი გამოყენებით შესაძლებელია ყველა სხვა ლოგიკური ოპერაციის აგება.",
        "symbol": "⊽"
      },
      "xor": {
        "title": "გამომრიცხავი ან(XOR): ექსკლუზიური გადაწყვეტილების მიმღები",
        "description": "XOR პრეტენზიულ მჭამელს ჰგავს - ის მხოლოდ მაშინ არის კმაყოფილი (აბრუნებს ჭეშმარიტს), როდესაც ზუსტად ერთი ვარიანტია ხელმისაწვდომი, არა ორივე და არც არცერთი.",
        "explanation": "წარმოიდგინეთ, რომ არდადეგებზე წასვლას გეგმავთ: ზღვაზე ან მთაში. XOR ისე მოქმედებს, როგორც ნათქვამი: 'მინდა წავიდე ან ზღვაზე, ან მთებში, მაგრამ არა ორივეგან ერთად!' ის ჭეშმარიტია, როცა ერთი ვარიანტი ჭეშმარიტია, ხოლო მეორე - მცდარი. პროგრამირებაში XOR შესანიშნავია როდესაც გჭირდებათ დარწმუნდეთ, რომ ორი პირობიდან ზუსტად ერთი სრულდება, მაგრამ არასდროს ორივე ერთად.",
        "symbol": "⊕"
      },
      "truthTables": {
        "title": "ჭეშმარიტების ცხრილი",
        "tableHeaderA": "პირობა A",
        "tableHeaderB": "პირობა B",
        "tableHeaderResult": "შედეგი"
      },
      "advancedLogicalOperatorGame": {
        "title": "ლოგიკური ოპერატორების თამაში",
        "introduction": "შეამოწმეთ თქვენი ოსტატობა NAND, NOR და XOR ოპერატორებში. რამდენ ამოცანას გადაჭრით 30 წამში?",
        "time": "დრო",
        "score": "ქულა",
        "gameOver": "გამოწვევა დასრულებულია!",
        "finalScore": "საბოლოო ქულა",
        "startGame": "გამოწვევის დაწყება",
        "playAgain": "ხელახლა ცდა",
        "true": "ჭეშმარიტი",
        "false": "მცდარი"
      }
    },
    "problems": {
      "title": "ამოცანები ლოგიკურ ოპერატორებზე"
    }
  },
  "numberTheory": {
    "introduction": {
      "title": "შესავალი რიცხვთა თეორიაში",
      "description": "რიცხვთა თეორია არის წმინდა მათემატიკის დარგი, რომელიც ძირითადად ეძღვნება მთელი რიცხვებისა და ისეთი ფუნქციების შესწავლას, რომელიც მოქმედებს მთელ რიცხვებზე. ეს არის მათემატიკის ერთ-ერთი უძველესი და ფუნდამენტური სფერო, მდიდარი ისტორიით, რომელიც უძველეს ცივილიზაციებამდე მიდის.",
      "keyConcepts": {
        "title": "ძირითადი კონცეფციები რიცხვთა თეორიაში:",
        "list": [
          "მარტივი რიცხვები: რიცხვები, რომლებიც აღემატებიან 1-ს და არ აქვთ სხვა დადებითი გამყოფები გარდა 1-ისა და საკუთარი თავისა.",
          "გაყოფადობა: როდის იყოფა ერთი მთელი რიცხვი მეორე მთელ რიცხვზე უნაშთოდ.",
          "უდიდესი საერთო გამყოფი (უსგ): უდიდესი დადებითი მთელი რიცხვი, რომელიც ყოფს თითოეულ რიცხვს ნაშთის გარეშე.",
          "უმცირესი საერთო ჯერადი (უსჯ): უმცირესი დადებითი მთელი რიცხვი, რომელიც იყოფა თითოეულ რიცხვზე.",
          "მოდულარული არითმეტიკა: არითმეტიკა, რომელიც ეხება ნაშთებს გაყოფის შემდეგ.",
          "დიოფანტური განტოლებები: პოლინომიალური განტოლებები, სადაც მხოლოდ ამონახსნები მოიძებნება მხოლოდ მთელ რიცხვებში."
        ]
      },
      "applications": {
        "title": "რიცხვთა თეორიის გამოყენებები:",
        "list": [
          "კრიპტოგრაფია: ბევრი შიფრაციის მეთოდი, მათ შორის RSA, დაფუძნებულია რიცხვთა თეორიის პრინციპებზე.",
          "კომპიუტერული მეცნიერება: ალგორითმები, მონაცემთა სტრუქტურები და შეცდომების გასწორების კოდები ხშირად ეყრდნობა რიცხვთა თეორიის კონცეფციებს.",
          "ინჟინერია: გამოყენებები სიგნალების დამუშავებაში, მართვის თეორიაში და სხვა საინჟინრო სფეროებში."
        ]
      }
    },
    "lcmAndGcd": {
      "title": "უმცირესი საერთო ჯერადი (უსჯ) და უდიდესი საერთო გამყოფი (უსგ)",
      "whatAre": {
        "title": "რა არის უსჯ და უსგ?",
        "lcm": {
          "title": "უმცირესი საერთო ჯერადი (უსჯ)",
          "description": "ორი ან მეტი მთელი რიცხვის უსჯ არის უმცირესი დადებითი მთელი რიცხვი, რომელიც იყოფა თითოეულ ამ რიცხვზე. მაგალითად, 4-ისა და 6-ის უსჯ არის 12."
        },
        "gcd": {
          "title": "უდიდესი საერთო გამყოფი (უსგ)",
          "description": "ორი ან მეტი მთელი რიცხვის უსგ არის უდიდესი დადებითი მთელი რიცხვი, რომელიც ყოფს თითოეულ ამ რიცხვს ნაშთის გარეშე. მაგალითად, 8-ისა და 12-ის უსგ არის 4."
        }
      },
      "importance": {
        "title": "რატომ არის მნიშვნელოვანი უსჯ და უსგ?",
        "list": [
          "უსჯ გამოიყენება მათემატიკის მრავალ სფეროში, მათ შორის წილადებში, ალგებრასა და რიცხვთა თეორიაში.",
          "უსგ დიდ როლს ასრულებს წილადების გამარტივებაში, დიოფანტური განტოლებების ამოხსნაში და კომპიუტერული მეცნიერების სხვადასხვა ალგორითმებში.",
          "როგორც უსჯ, ისე უსგ მნიშვნელოვანია კრიპტოგრაფიაში, განსაკუთრებით RSA ალგორითმში.",
          "კომპიუტერულ პროგრამირებაში, უსჯ და უსგ გამოიყენება სხვადასხვა ალგორითმებსა და მონაცემთა სტრუქტურებში."
        ]
      },
      "calculation": {
        "title": "როგორ გამოვთვალოთ უსჯ და უსგ",
        "gcd": {
          "title": "უსგ-ს გამოთვლა",
          "description": "უსგ-ს გამოსათვლელად ყველაზე ეფექტური მეთოდია ევკლიდეს ალგორითმი:",
          "steps": [
            "გაყავით დიდი რიცხვი პატარაზე.",
            "შეცვალეთ დიდი რიცხვი პატარა რიცხვით, ხოლო პატარა რიცხვი - პირველი ნაბიჯის ნაშთით.",
            "გაიმეორეთ, სანამ ნაშთი არ გახდება ნული. ბოლო არანულოვანი ნაშთი არის უსგ."
          ]
        },
        "lcm": {
          "title": "უსჯ-ს გამოთვლა",
          "description": "უსჯ შეგიძლიათ, რომ გამოთვალოთ შემდეგი ფორმულით:",
          "formula": "უსჯ(a, b) = |a * b| / უსგ(a, b)",
          "note": "სადაც |a * b| აღნიშნავს a * b-ს აბსოლუტურ მნიშვნელობას."
        }
      },
      "examples": {
        "title": "მაგალითები",
        "gcd": {
          "title": "უსგ-ს მაგალითი: გამოვთვალოთ უსგ(48, 18)",
          "steps": [
            "48 ÷ 18 = 2 ნაშთი 12",
            "18 ÷ 12 = 1 ნაშთი 6",
            "12 ÷ 6 = 2 ნაშთი 0",
            "ბოლო არანულოვანი ნაშთი არის 6, ამიტომ უსგ(48, 18) = 6"
          ]
        },
        "lcm": {
          "title": "უსჯ-ს მაგალითი: გამოვთვალოთ უსჯ(12, 18)",
          "steps": [
            "ჯერ გამოვთვალოთ უსგ(12, 18) = 6",
            "უსჯ(12, 18) = |12 * 18| / 6 = 216 / 6 = 36"
          ]
        }
      },
      "calculator": {
        "enterFirstNumber": "შეიყვანეთ პირველი რიცხვი",
        "enterSecondNumber": "შეიყვანეთ მეორე რიცხვი",
        "lcm": "უ.ს.ჯ",
        "gcd": "უ.ს.გ"
      }
    },
    "modularArithmetic": {
      "title": "მოდულარული არითმეტიკა",
      "description": "მოდულარული არითმეტიკა არის არითმეტიკის სისტემა მთელი რიცხვებისთვის, სადაც რიცხვები 'ტრიალდება' გარკვეული მნიშვნელობის - მოდულის მიღწევისას. მას მნიშვნელოვანი გამოყენება აქვს კომპიუტერულ მეცნიერებაში, კრიპტოგრაფიასა და ყოველდღიურ ცხოვრებაში.",
      "basics": {
        "title": "მოდულარული არითმეტიკის საფუძვლები",
        "description": "მოდულარულ არითმეტიკაში ჩვენ ორ რიცხვს ეკვივალენტურად მივიჩნევთ, თუ ისინი ტოვებენ ერთსა და იმავე ნაშთს მოდულზე გაყოფისას. ჩვენ ვწერთ a ≡ b (mod m), რაც ნიშნავს, რომ a და b კონგრუენტულია მოდულით m.",
        "example": "მაგალითად, 38 ≡ 14 (mod 12), რადგან 38-იც და 14-იც გვაძლევს ნაშთს 2-ს, როცა იყოფა 12-ზე."
      },
      "operations": {
        "title": "ოპერაციები მოდულარულ არითმეტიკაში",
        "description": "მოდულარული არითმეტიკა მოიცავს სტანდარტული არითმეტიკის მსგავს ოპერაციებს, მაგრამ შედეგები 'ტრიალდება' მოდულის მიხედვით:",
        "list": [
          "შეკრება: (a + b) mod m",
          "გამოკლება: (a - b) mod m",
          "გამრავლება: (a * b) mod m",
          "ახარისხება: (a^b) mod m"
        ],
        "example": "მაგალითად: 5 + 4 ≡ 2 (mod 7), რადგან 9 ≡ 2 (mod 7)"
      },
      "properties": {
        "title": "მოდულარული არითმეტიკის თვისებები",
        "description": "მოდულარულ არითმეტიკას აქვს რამდენიმე მნიშვნელოვანი თვისება:",
        "list": [
          "ჩაკეტილობა: ნებისმიერი ოპერაციის შედეგი ყოველთვის არის m მოდულის ნაშთების სიმრავლიდან",
          "ჯუფთებადობა: (a + b) + c ≡ a + (b + c) (mod m)",
          "გადანაცვლებადობა: a + b ≡ b + a (mod m)",
          "განრიგებადობა: a * (b + c) ≡ (a * b + a * c) (mod m)"
        ]
      },
      "applications": {
        "title": "მოდულარული არითმეტიკის გამოყენებები",
        "description": "მოდულარულ არითმეტიკას აქვს მრავალი პრაქტიკული გამოყენება:",
        "list": [
          "კრიპტოგრაფია: RSA შიფრაცია იყენებს მოდულარულ ახარისხებას",
          "ჰეშ ფუნქციები: გამოიყენება ციფრულ ხელმოწერებში და ბლოკჩეინ ტექნოლოგიაში",
          "კომპიუტერული მეცნიერება: ციკლური მონაცემთა სტრუქტურების დამუშავება და მთელი რიცხვების გადავსების თავიდან აცილება",
          "საათის არითმეტიკა: დროის წარმოდგენა 12-საათიან ან 24-საათიან ფორმატში"
        ]
      },
      "realLifeExamples": {
        "title": "მოდულარული არითმეტიკის რეალური მაგალითები",
        "examples": [
          "საათის არითმეტიკა: როცა 10 საათია და 5 საათი გავა, გახდება 3 საათი (10 + 5 ≡ 3 mod 12).",
          "კვირის დღე: თუ დღეს სამშაბათია (დღე 2) და 10 დღე გავა, იქნება პარასკევი (2 + 10 ≡ 5 mod 7).",
          "მბრუნავი ცვლები: ქარხანაში 3 ცვლით, 100 დღის შემდეგ ცვლა იგივე იქნება, რაც პირველ დღეს (100 ≡ 1 mod 3)."
        ]
      },
      "calculator": {
        "title": "მოდულარული არითმეტიკის კალკულატორი",
        "description": "გამოიყენეთ ეს კალკულატორი მოდულარული არითმეტიკული ოპერაციების შესასრულებლად. შეიყვანეთ ორი რიცხვი, აირჩიეთ ოპერაცია და მიუთითეთ მოდული შედეგის სანახავად.",
        "result": "შედეგი: {{a}} {{operation}} {{b}} ≡ {{result}} (mod {{m}})"
      }
    },
    "rsaAlgorithm": {
      "title": "RSA ალგორითმი",
      "whatIsRSA": {
        "title": "რა არის RSA?",
        "description1": "RSA (Rivest-Shamir-Adleman) არის საჯარო გასაღების კრიპტოსისტემა, რომელიც ფართოდ გამოიყენება მონაცემთა უსაფრთხო გადაცემისთვის. ეს არის ასიმეტრიული კრიპტოგრაფიული ალგორითმი, რაც იმას ნიშნავს, რომ იგი იყენებს ორ სხვადასხვა გასაღებს: საჯარო გასაღებს დაშიფვრისთვის და საიდუმლო გასაღებს გაშიფვრისთვის.",
        "description2": "RSA პირველად აღწერეს 1977 წელს რონ რივესტმა, ადი შამირმა და ლეონარდ ადლემანმა MIT-ში. ასოები RSA არის მათი გვარების ინიციალები. ეს იყო ერთ-ერთი პირველი პრაქტიკული საჯარო გასაღების კრიპტოსისტემა და კვლავ ფართოდ გამოიყენება მონაცემთა უსაფრთხო გადაცემისთვის."
      },
      "importance": {
        "title": "რამდენად მნიშვნელოვანია RSA",
        "list": [
          "უსაფრთხოება: RSA-ს უსაფრთხოება ეფუძნება ორი დიდი მარტივი რიცხვის ნამრავლის ფაქტორიზაციის პრაქტიკულ სირთულეს, რაც ცნობილია როგორც ფაქტორიზაციის პრობლემა.",
          "ციფრული ხელმოწერები: RSA შეიძლება გამოყენებულ იქნას ციფრული ხელმოწერების შესაქმნელად, რაც უზრუნველყოფს ციფრული შეტყობინებების ან დოკუმენტების ავთენტურობასა.",
          "გასაღების გაცვლა: იგი საშუალებას იძლევა უსაფრთხოდ გაცვალოთ გასაღებები არაუსაფრთხო არხებზე, რაც მნიშვნელოვანია უსაფრთხო კომუნიკაციის დამყარებისთვის.",
          "ფართო გამოყენება: RSA გამოიყენება მრავალ პროტოკოლში, მათ შორის SSL/TLS-ში, რომელიც გამოიყენება ინტერნეტ კომუნიკაციების დასაცავად."
        ]
      },
      "howItWorks": {
        "title": "როგორ მუშაობს RSA: დეტალური ნაბიჯები",
        "keyGeneration": {
          "title": "1. გასაღების გენერაცია:",
          "steps": [
            "აირჩიეთ ორი განსხვავებული დიდი მარტივი რიცხვი p და q.",
            "გამოთვალეთ n = p * q. n წარმოადგენს მოდულს როგორც საჯარო, ისე საიდუმლო გასაღებისთვის.",
            "გამოთვალეთ φ(n) = (p-1) * (q-1). ეს არის ეილერის ფუნქცია.",
            "აირჩიეთ მთელი რიცხვი e ისე, რომ 1 < e < φ(n) და gcd(e, φ(n)) = 1. e არის საჯარო ექსპონენტი.",
            "გამოთვალეთ d, რომელიც წარმოადგენს e-ს შებრუნებას მოდულით n (mod φ(n)). ეს d არის საიდუმლო ექსპონენტი."
          ]
        },
        "keyDistribution": {
          "title": "2. გასაღების განაწილება:",
          "steps": [
            "საჯარო გასაღებია (e, n). იგი ცნობილია ყველასთვის და გამოიყენება დასაიფრად.",
            "საიდუმლო გასაღებია (d, n). იგი უნდა იყოს საიდუმლოდ შენახული, რადგან გამოიყენება გაშიფვრისთვის."
          ]
        },
        "encryption": {
          "title": "3. დაშიფვრა:",
          "steps": [
            "გადაიყვანეთ შეტყობინება რიცხვში m, სადაც 0 ≤ m < n.",
            "გამოთვალეთ დაშიფრული ტექსტი c = mᵉ (mod n)."
          ]
        },
        "decryption": {
          "title": "4. გაშიფვრა:",
          "steps": [
            "გამოიყენეთ საიდუმლო გასაღები (d, n) m-ის გამოსათვლელად: m = cᵈ (mod n).",
            "გადაიყვანეთ m უკან ორიგინალ შეტყობინებაში."
          ]
        }
      },
      "mathematicalFoundation": {
        "title": "მათემატიკური საფუძველი",
        "description": "RSA-ს უსაფრთხოება ეფუძნება ორ მათემატიკურ ფაქტს:",
        "fact1": "1. მოდულარული ახარისხება: n = p * q და c = mᵉ (mod n)-ის გამოთვლა არის მარტივი.",
        "fact2": "2. მარტივ მამრავლებად დაშლა: რთულია p-ს და q-ს განსაზღვრა n-დან, განსაკუთრებით მაშინ, როცა p და q დიდი მარტივი რიცხვებია.",
        "additional": "ალგორითმი ასევე ეყრდნობა ეილერის თეორემას და მოდულარული არითმეტიკის თვისებებს, რათა უზრუნველყოს, რომ დაშიფვრა და გაშიფვრა არიან შებრუნებული ოპერაციები."
      },
      "securityConsiderations": {
        "title": "უსაფრთხოების მიმოხილვა",
        "list": [
          "გასაღების ზომა: RSA-ს უსაფრთხოება დამოკიდებულია n-ის ზომაზე. 2021 წლის მდგომარეობით, 2048 ბიტის ზომის გასაღები უსაფრთხოდ ითვლება ძირითად შემთხვევებში.",
          "მარტივი რიცხვების გენერაცია: მარტივი რიცხვები p და q უნდა იყოს გენერირებული შემთხვევითად და შენახული საიდუმლოდ.",
          "იმპლემენტაციები უნდა იყოს ფრთხილი, რათა თავიდან აიცილოს ინფორმაციის გაჟონვა დროის ან ენერგიის მოხმარების გზით."
        ]
      },
      "practicalExample": {
        "title": "პრაქტიკული მაგალითი",
        "description": "განვიხილოთ მარტივი მაგალითი პატარა რიცხვებით (შენიშვნა: პრაქტიკაში გამოიყენება გაცილებით დიდი რიცხვები):",
        "steps": [
          "ავიღოთ p = 61 და q = 53",
          "გამოვთვალოთ n = 61 * 53 = 3233",
          "გამოვთვალოთ φ(n) = (61-1) * (53-1) = 3120",
          "ავიღოთ e = 17 (თანამარტივი 3120-თან)",
          "ვიპოვოთ ისეთი d, რომ (d * 17) mod 3120 = 1. d = 2753",
          "საჯარო გასაღებია (17, 3233), საიდუმლო გასაღები არის (2753, 3233)",
          "m = 123-ის დასაშიფრად: c = 123¹⁷ mod 3233 = 855",
          "c = 855-ის გასაშიფრად: m = 855²⁷⁵³ mod 3233 = 123"
        ]
      },
      "calculator": {
        "title": "RSA ალგორითმის კალკულატორი",
        "prime": "მარტივი რიცხვი",
        "generateKeys": "გასაღების გენერაცია",
        "publicKey": "საჯარო გასაღები",
        "privateKey": "საიდუმლო გასაღები",
        "encrypt": "დაშიფვრა",
        "decrypt": "გაშიფვრა",
        "encrypted": "დაშიფრული შეტყობინება",
        "decrypted": "გაშიფრული შეტყობინება",
        "messageToEncrypt": "დასაშიფრი შეტყობინება"
      }
    }
  },
  "graphTheory": {
    "introduction": {
      "title": "შესავალი გრაფთა თეორიაში",
      "graphDefinition": {
        "title": "გრაფის განმარტება",
        "definition": "გრაფი არის მათემატიკური სტრუქტურა, რომელიც შედგება ორი სიმრავლისგან:",
        "vertices": "V (წვეროები): ელემენტების არასაცარიელი სიმრავლე, რომელსაც ეწოდება წვეროები.",
        "edges": "E (წიბოები): სიმრავლე წვეროების წყვილებისა, რომლებიც მათ შორის კავშირს ასახავენ.",
        "formal": "მათემატიკურად, გრაფი ჩაიწერება როგორც: G = (V, E).",
        "explanation": "ზემოთ ნაჩვენებია მარტივი არამიმართული გრაფი, რომელსაც აქვს 6 წვერო და 9 წიბო.",
        "interactionPrompt": "თქვენ შეგიძლიათ დააწკაპუნოთ და გადაადგილოთ წიბოები!"
      },
      "graphDirectedness": {
        "title": "არამიმართული და მიმართული გრაფები",
        "definition": "გრაფები შეიძლება დავყოთ ორ ჯგუფად: არამიმართული და მიმართული, მათი წიბოების ბუნების მიხედვით:",
        "undirected": {
          "label": "არამიმართული გრაფი",
          "description": "წიბოებს არ აქვთ მიმართულება. კავშირი წვეროებს შორის სიმეტრიულია."
        },
        "directed": {
          "label": "მიმართული გრაფი",
          "description": "წიბოებს აქვთ მიმართულება. კავშირი წვეროებს შორის შეიძლება იყოს ასიმეტრიული."
        },
        "selectedEdge": "არჩეული წიბო: {{edge}}",
        "prompt": "დააწკაპუნეთ გრაფის წიბოზე, რათა ნახოთ განსხვავება ვიზუალურად.",
        "interactionPrompt": "დააწკაპუნეთ წიბოებზე ორივე გრაფში, რათა შეადაროთ არამიმართული და მიმართული გრაფები!"
      },
      "verticesAndEdges": {
        "title": "წვეროები და წიბოები",
        "description": "გრაფი შედგება ორი მთავარი ელემენტისგან:",
        "vertices": {
          "label": "წვეროები",
          "description": "წერტილები ან წრეები გრაფში"
        },
        "edges": {
          "label": "წიბოები",
          "description": "წიბოები, რომლებიც აკავშირებს წვეროებს"
        },
        "explanation": "მაგალითი: წრეები არის წვეროები. ხაზები, რომლებიც აკავშირებს ამ წვეროებს, არის წიბოები. მიმართულ გრაფში (მარჯვნივ), წვეროებს აქვს ისრები, რომლებიც მიუთითებს მიმართულებას.",
        "interactionPrompt": "დააწკაპუნეთ \"წვეროებს\" ან \"წიბოებს\" ზემოთ, რათა აღიქვათ ისინი!",
        "undirectedGraph": "არამიმართული გრაფი",
        "directedGraph": "მიმართული გრაფი"
      },
      "vertexDegree": {
        "title": "წვეროს ხარისხი",
        "description": "წვეროს ხარისხი არის წიბოების რაოდენობა, რომლებიც მასთან არის დაკავშირებული. სხვა სიტყვებით, ეს არის მეზობლების რაოდენობა, რომლებიც წვეროს ჰყავს.",
        "undirectedGraphDescription": "არამიმართული გრაფებისთვის, ეს უბრალოდ წვეროსთან დაკავშირებული წიბოების რაოდენობაა.",
        "directedGraphDescription": "მიმართულ გრაფებში, ჩვენ განვასხვავებთ შემომავალი და გამავალი წიბოების რაოდენობას.",
        "undirectedGraph": "არამიმართული გრაფი",
        "directedGraph": "მიმართული გრაფი",
        "undirectedDegreeExplanation": "არამიმართულ გრაფში {{selectedNode}} წვეროს ხარისხი არის {{undirectedDegree}}.",
        "directedDegreeExplanation": "მიმართულ გრაფში {{selectedNode}} წვეროს აქვს {{inDegree}} შემომავალი და {{outDegree}} გამავალი წიბო.",
        "selectVertexPrompt": "დააჭირეთ წვეროს ორივე გრაფში, რათა იხილოთ მისი ხარისხი.",
        "interactionPrompt": "დააჭირეთ სხვადასხვა წვეროს ორივე გრაფში, რათა შეადაროთ წვეროების ხარისხი არამიმართულ და მიმართულ გრაფებში!"
      },
      "pathsAndCycles": {
        "title": "გზები და ციკლები გრაფებში",
        "description": "გრაფთა თეორიაში გზები და ციკლები საბაზისო ცნებებია: გზა არის წვეროების თანმიმდევრობა, რომლებიც დაკავშირებულია წიბოებით, ყოველგვარი გამეორების გარეშე. ციკლი არის გზა, რომელიც იწყება და მთავრდება ერთი და იმავე წვეროთი.",
        "pathExplanation": "ეს არის გზა: e → f → g → a → b → c → d: ერთმანეთთან დაკავშირებული წვეროების თანმიმდევრობა გამეორების გარეშე.",
        "cycleExplanation": "ეს არის ციკლი: a → b → c → f → g → a. ის იწყება და მთავრდება ერთიდაიმავე წვეროთი.",
        "showPathButton": "გზის ჩვენება",
        "showCycleButton": "ციკლის ჩვენება",
        "interactiveDescription": "ააგეთ საკუთარი გრაფი, შემდეგ კი აღმოაჩინეთ ციკლები თქვენს გრაფში.",
        "resetButton": "გრაფის გადატვირთვა",
        "cyclesDetected": "გრაფში ნაპოვნი ციკლების რაოდენობა",
        "interactivePrompt": "დააწკაპუნეთ ეკრანზე წვეროების დასამატებლად. დააწკაპუნეთ ორ წვეროზე ზედიზედ მათ შორის წიბოს ასაგებად."
      },
      "graphConnectivity": {
        "title": "კავშირი გრაფებში",
        "description": "კავშირი გრაფებში განსხვავდება იმის მიხედვით, არის თუ არა ყველა წვერო დაკავშირებული ერთმანეთთან. გრაფი არის ბმული, თუ არსებობს გზა ყოველ წყვილ წვეროს შორის.",
        "connectedGraph": "ბმული გრაფი",
        "disconnectedGraph": "არაბმული გრაფი",
        "connectedExplanation": "ამ ბმულ გრაფში შეგიძლიათ მიწვდეთ ნებისმიერ წვეროს ნებისმიერი სხვა წვეროდან.",
        "disconnectedExplanation": "ამ არაბმულ გრაფში ორი ცალკეული კომპონენტია. თქვენ ვერ იპოვით გზას C ან D-დან A ან B-მდე.",
        "additionalInfo": "ბმულ გრაფს აქვს მხოლოდ ერთი კომპონენტი, მაშინ როცა არაბმული გრაფს აქვს ორი ან მეტი კომპონენტი. კომპონენტები ისეთი ქვეგრაფებია, სადაც ყველა წვერო დაკავშირებულია ერთმანეთთან, მაგრამ არაა დაკავშირებული სხვა კომპონენტების წვეროებთან."
      },
      "subgraphs": {
        "title": "ქვეგრაფები",
        "description": "ქვეგრაფი არის გრაფი, რომლის წვეროებისა და წიბოების სიმრავლე სხვა გრაფის ქვესიმრავლეა. ეს არის დიდი გრაფის პატარა ნაწილი, რომელშიც შენარჩუნებულია იგივე კავშირები, რაც თავდაპირველ გრაფში იყო.",
        "fullGraphExplanation": "ეს არის სრული გრაფი. ქვეგრაფი არის წვეროებისა და წიბოების ნაკრები ამ გრაფიდან.",
        "triangleExplanation": "ეს სამკუთხედი (A-B-C) არის ქვეგრაფი. მას აქვს ზოგიერთი, მაგრამ არა ყველა თავდაპირველი გრაფის წვერო და წიბო.",
        "pathExplanation": "ეს გზა (B-C-D-E) ასევე არის ქვეგრაფი. ის არის დაკავშირებული წვეროების მიმდევრობა, რომელიც შედის უფრო დიდ გრაფში.",
        "showFullGraph": "მაჩვენე სრული გრაფი",
        "showTriangle": "მაჩვენე სამკუთხედის ფორმის ქვეგრაფი",
        "showPath": "მაჩვენე გზის ფორმის ქვეგრაფი",
        "resetButton": "გადატვირთვა"
      }
    },
    "differentGraphs": {
      "title": "სხვადასხვა ტიპის გრაფები",
      "weightedGraphs": {
        "title": "წონიანი გრაფები",
        "description": "წონიანი გრაფებში თითოეულ წიბოს მინიჭებული აქვს რიცხვობრივი მნიშვნელობა, რომელსაც წონა ეწოდება. ეს წონები შეიძლება წარმოადგენდეს სხვადასხვა რეალურ რაოდენობას, როგორიცაა მანძილი ან ღირებულება. არსებობს წონიანი გრაფების ორი ძირითადი ტიპი:",
        "undirectedDescription": "არამიმართული წონიანი გრაფები: წიბოებს არ აქვთ მიმართულება და წონა მოქმედებს ორივე მიმართულებით დაკავშირებულ წვეროებს შორის.",
        "directedDescription": "მიმართული წონიანი გრაფები: წიბოებს აქვთ კონკრეტული მიმართულება და წონა მოქმედებს მხოლოდ ამ მიმართულებით.",
        "undirectedGraph": "არამიმართული წონიანი გრაფი",
        "directedGraph": "მიმართული წონიანი გრაფი",
        "edgeWeightExplanation": "არჩეულ წიბოს {{selectedElement}} აქვს წონა {{weight}}.",
        "nodeExplanation": "თქვენ აირჩიეთ წვერო {{selectedElement}}. წონიან გრაფში წონების ცნება დაკავშირებულია წიბოებთან და არა წვეროებთან.",
        "selectElementPrompt": "დააწკაპუნეთ წვეროზე ან წიბოზე მეტი ინფორმაციის სანახავად.",
        "interactionPrompt": "გაეცანით ზემოთ მოცემულ გრაფებ წონიანი გრაფების კონცეფციის უკეთ შესასწავლად. დააწკაპუნეთ წიბოებზე მათი წონების სანახავად, ან წვეროებზე წონიან გრაფებში მათი როლის გასაგებად."
      },
      "planarGraphs": {
        "planarTitle": "ბრტყელი გრაფები",
        "planarDescription": "ბრტყელი გრაფი არის ისეთი გრაფი, რომელიც სიბრტყეზე ისე შეიძლება დაიხატოს, რომ მისი წიბოები არსად გადაიკვეთოს, მხოლოდ წვეროსთან. ეს ნიშნავს, რომ წიბოები მხოლოდ მათი ბოლოებით ეხებიან ერთმანეთს.",
        "planarLabel": "ბრტყელი გრაფი",
        "nonPlanarLabel": "არაბრტყელი გრაფი",
        "planarInteractionPrompt": "შეცვალეთ წვეროების რაოდენობა და დააკვირდით როგორ იცვლება ბრტყელი და არაბრტყელი გრაფების ვიზუალი.",
        "numberOfNodes": "წვეროების რაოდენობა"
      },
      "bipartiteGraphs": {
        "title": "ორნაწილიანი გრაფი",
        "description": "ორნაწილიანი გრაფი არის გრაფი, რომლის წვეროები შეიძლება გაიყოს ორ განცალკევებულ სიმრავლედ ისე, რომ ყოველი წიბო აკავშირებდეს ერთი სიმრავლის წვეროს მეორე სიმრავლის წვეროსთან. სხვა სიტყვებით რომ ვთქვათ, არ არსებობს წიბოები ერთი და იმავე სიმრავლის წვეროებს შორის.",
        "bipartiteLabel": "ორნაწილიანი გრაფი",
        "examples": {
          "0": "სტუდენტები და კლასები: ერთი სიმრავლე წარმოადგენს სტუდენტებს, მეორე - კლასებს. წიბოები გვიჩვენებს, რომელი სტუდენტები არიან ჩარიცხულნი რომელ კლასებში.",
          "1": "მსახიობები და ფილმები: ერთი სიმრავლე მსახიობებისთვის, მეორე - ფილმებისთვის. წიბოები გვიჩვენებს, თუ რომელი მსახიობები მონაწილეობენ რომელ ფილმებში.",
          "2": "ავტორები და წიგნები: ერთი სიმრავლე ავტორებისთვის, მეორე - წიგნებისთვის. წიბოები წარმოადგენს, თუ რომელმა ავტორებმა დაწერეს რომელი წიგნები."
        },
        "applicationNote": "ეს მაგალითები აჩვენებს, თუ როგორ შეუძლიათ ორნაწილიან გრაფებს წარმოადგინონ ურთიერთობები ორი განსხვავებული ტიპის ობიექტებს შორის, რაც მათ ძლიერ ინსტრუმენტებად აქცევს სხვადასხვა სისტემებისა თუ ქსელების ანალიზისა და ვიზუალიზაციისთვის.",
        "nonBipartiteLabel": "არაორნაწილიანი გრაფი",
        "interactionPrompt": "შეცვალეთ ორივე გრაფში წვეროების რაოდენობა და დააკვირდით, როგორ ინარჩუნებს ორნაწილიანი გრაფი ყოველთვის წვეროების ორ განსხვავებულ სიმრავლეს, მაშინ როცა არაორნაწილიანი გრაფი უშვებს კავშირებს ერთი და იმავე სიმრავლის შიგნით.",
        "numberOfNodes": "წვეროების რაოდენობა"
      },
      "regularGraphs": {
        "title": "რეგულარული გრაფი",
        "description": "რეგულარული გრაფი არის გრაფი, სადაც თითოეულ წვეროს აქვს მეზობლების ერთნაირი რაოდენობა; სხვა სიტყვებით, ყველა წვეროს აქვს ერთი და იგივე ხარისხი. რეგულარული გრაფები ფუნდამენტურია გრაფთა თეორიაში და აქვთ სხვადასხვა გამოყენება ქსელების დიზაინში, ქიმიაში თუ სოციალური ქსელების ანალიზში.",
        "numberOfVertices": "წვეროების რაოდენობა",
        "degree": "ხარისხი",
        "oddEvenDescription": "წვეროების რაოდენობა და რეგულარული გრაფის ხარისხი მჭიდროდ არის დაკავშირებული. იმისათვის, რომ რეგულარული გრაფი არსებობდეს, წვეროების რაოდენობისა და ხარისხის ნამრავლი უნდა იყოს ლუწი. ეს იმიტომ, რომ თითოეული წიბო ორი წვეროს ხარისხში იანგარიშება. შედეგად, კენტი რაოდენობის წვეროების მქონე რეგულარულ გრაფებს უნდა ჰქონდეთ ლუწი ხარისხი, ხოლო ლუწი რაოდენობის წვეროების მქონე გრაფებს შეიძლება ჰქონდეთ როგორც კენტი, ისე ლუწი ხარისხი. გაეცანით ამ დამოკიდებულებებს ქვემოთ მოცემული წვეროების რაოდენობისა და ხარისხის რეგულირებით.",
        "interactionPrompt": "გამოიყენეთ ქვემოთ მოცემული ღილაკები წვეროების რაოდენობისა და ხარისხის შესაცვლელად. დააკვირდით, როგორ იცვლება რეგულარული გრაფი და რომელი კომბინაციებია შესაძლებელი ან შეუძლებელი."
      },
      "completeGraphs": {
        "title": "სრული გრაფი",
        "description": "სრული გრაფი არის გრაფი, რომელშიც ყოველი წყვილი განსხვავებული წვერო დაკავშირებულია უნიკალური წიბოთი. n წვეროს მქონე სრულ გრაფში თითოეულ წვეროს აქვს n-1 ხარისხი, ხოლო წიბოების საერთო რაოდენობა არის n(n-1)/2.",
        "interactionPrompt": "გამოიყენეთ ქვემოთ მოცემული ღილაკები წვეროების რაოდენობის შესაცვლელად. დააკვირდით, როგორ იცვლება წიბოების რაოდენობა და თითოეული წვეროს ხარისხი გრაფის მოდიფიცირებისას.",
        "numberOfVertices": "წვეროების რაოდენობა",
        "edgeCount": "წიბოების რაოდენობა: {{num}}",
        "degreeProp": "თითოეული წვეროს ხარისხი: {{degree}}"
      },
      "trees": {
        "title": "ხეები",
        "description": "გრაფთა თეორიაში, ხე არის ბმული, აციკლური გრაფი. ხეები გამოიყენება იერარქიების წარმოსადგენად და ეფექტური ალგორითმების შესაქმნელად.",
        "tree1": "ორობითი ხე",
        "tree1Explanation": "ორობითი ხე არის ხე, რომელშიც თითოეულ წვეროს ჰყავს მაქსიმუმ ორი შვილი. ხშირად გამოიყენება ეფექტური ძებნისა და დახარისხების ალგორითმებისთვის.",
        "tree2": "ზოგადი ხე",
        "tree2Explanation": "ზოგადი ხე, რომელშიც წვეროებს შეიძლება ჰყავდეთ ნებისმიერი რაოდენობის შვილი. სასარგებლოა რთული იერარქიების წარმოსადგენად, როგორიცაა ფაილური სისტემები ან ორგანიზაციული სქემები.",
        "interactionPrompt": "დაათვალიერეთ მოცემული ორი ტიპის ხე."
      }
    },
    "graphTraversals": {
      "title": "ძიება გრაფში",
      "bfs": {
        "title": "სიგანეში ძებნა",
        "explanation": "სიგანეში ძიება (BFS) ჰგავს ქალაქის კვარტალ-კვარტალ შესწავლას. წარმოიდგინეთ, რომ დგახართ თქვენს სახლთან (საწყისი წვერო) და გსურთ კონკრეტული ადგილის პოვნა. ნაცვლად იმისა, რომ ერთ გრძელ ქუჩაზე იაროთ, თქვენ ჯერ ეწვევით ყველა ადგილს თქვენს კვარტალში. შემდეგ გადადიხართ ყველა ისეთ ადგილას, რომელიც ერთი კვარტლის დაშორებითაა, შემდეგ ორი კვარტლის დაშორებით და ა.შ. ამგვარად, თქვენ დარწმუნებული ხართ, რომ ჯერ უახლოეს ადგილს წააწყდებით. გრაფების ტერმინებში, BFS იწყება არჩეული წვეროდან და იკვლევს ყველა მის მეზობელს, სანამ შემდეგ დონეზე გადავა. ის იყენებს რიგს (პროგრამირებაში Queue - ანალოგიურია ჩვეულებრივი რიგისა, პირველად მისული პირველად გადის რიგიდან) იმის დასამახსოვრებლად, თუ რომელი წვეროები უნდა მოინახულოს შემდეგ. ეს მეთოდი უზრუნველყოფს, რომ წვეროები მიიღწევა მათი საწყისი წერტილიდან დაშორების მიხედვით, რაც BFS-ს იდეალურს ხდის ორ წერტილს შორის უმოკლესი გზის საპოვნელად არაწონიან გრაფში. BFS ფართოდ გამოიყენება ისეთ აპლიკაციებში, როგორიცაა სოციალური ქსელები, GPS ნავიგაცია ახლომდებარე ადგილების საპოვნელად და თავსატეხების ამოხსნის ალგორითმებშიც კი!",
        "demoDescription": "უყურეთ ქვემოთ მოცემულ ანიმაციას, რათა ნახოთ, როგორ მოივლის BFS გრაფს სართულ-სართულ:",
        "interactionDescription": "ახლა სცადეთ საკუთარი გრაფის შექმნა და გაუშვით BFS, რომ ნახოთ, როგორ მუშაობს ის სხვადასხვა სტრუქტურებზე:",
        "interactionPrompt": "დააწკაპუნეთ ცარიელ სივრცეზე წვეროების დასამატებლად. დააწკაპუნეთ ზედიზედ ორ წვეროზე წიბოს შესაქმნელად. დააწკაპუნეთ წვეროზე, რომ მონიშნოთ ის საწყის წვეროდ (წვერო მწვანედ მოინიშნება). დააჭირეთ play ღილაკს BFS-ის დასაწყებად.",
        "unvisitedNode": "გავლილი წვერო",
        "visitedNode": "გაუვლელი წვერო",
        "currentNode": "მიმდინარე წვერო",
        "queuedNode": "რიგში მყოფი წვერო",
        "traversedEdge": "გავლილი წიბო"
      },
      "dfs": {
        "title": "სიღრმეში ძებნა",
        "explanation": "სიღრმეში ძებნა (DFS) ჰგავს ლაბირინთის კვლევას, როდესაც ყოველთვის ირჩევთ ყველაზე ღრმა გამოუკვლევ გზას. წარმოიდგინეთ, რომ ხართ მღვიმეთა სისტემაში: თქვენ აგრძელებთ სვლას გამოუკვლევ გვირაბებში, სანამ ჩიხს არ მიაღწევთ, შემდეგ კი უკან ბრუნდებით ბოლო გასაყარამდე, იქიდან კი გზას ისევ სიღრმეში აგრძელებთ. ეს მეთოდი უზრუნველყოფს, რომ ყველა შესაძლო გზა გამოიკვლიოთ.",
        "demoDescription": "უყურეთ ქვემოთ მოცემულ ანიმაციას, რომ ნახოთ, როგორ მოივლის DFS გრაფს, რომელიც ყოველთვის აირჩევს მარცხენა გამოუკვლევ გზას მაქსიმალური დაშორებით:",
        "interactionDescription": "ახლა სცადეთ საკუთარი გრაფის შექმნა და გაუშვით DFS, რომ ნახოთ, როგორ მუშაობს ის სხვადასხვა სტრუქტურებზე:",
        "interactionPrompt": "დააწკაპუნეთ წვეროების დასამატებლად. დააწკაპუნეთ ორ წვეროზე კავშირის შესაქმნელად. დააწკაპუნეთ წვეროზე, რომ დააყენოთ საწყისად. დააჭირეთ play ღილაკს DFS-ის დასაწყებად.",
        "unvisitedNode": "გავლილი წვერო",
        "visitedNode": "მონახულებული წვერო",
        "currentNode": "მიმდინარე წვერო",
        "stackNode": "მომლოდინე წვერო",
        "forwardEdge": "გავლილი წიბო",
        "runDFS": "DFS-ის გაშვება",
        "resetGraph": "გრაფის განულება"
      }
    },
    "graphAlgorithms": {
      "title": "გრაფების ალგორითმები",
      "graphIsomorphism": {
        "title": "გრაფების იზომორფიზმი",
        "introduction": "გრაფების იზომორფიზმი არის ფუნდამენტური ცნება გრაფთა თეორიაში, რომელიც გვეხმარება გავიგოთ, როდის აქვს ორ გრაფს ერთნაირი სტრუქტურა, მიუხედავად იმისა, თუ როგორ არიან ისინი გამოსახუები ან როგორაა მათი წვეროები დასახელებული.",
        "definitionTitle": "რა არის გრაფების იზომორფიზმი?",
        "definition": "ორი გრაფი G და H ითვლება იზომორფულად, თუ არსებობს ბიექციური ფუნქცია f G-ს წვეროებიდან H-ის წვეროებზე ისე, რომ ნებისმიერი ორი წვერო u და v მეზობლები არიან G-ში მაშინ და მხოლოდ მაშინ, როცა f(u) და f(v) მეზობლები არიან H-ში. მარტივად რომ ვთქვათ, იზომორფულ გრაფებს აქვთ ერთნაირი სტრუქტურა და შეიძლება ერთმანეთში გარდაიქმნან წვეროების გადარქმევით.",
        "determinationTitle": "როგორ განვსაზღვროთ იზომორფიზმი",
        "determination": "ორი გრაფის იზომორფულობის განსაზღვრა საკმაოდ რთული პროცესია. ამ პროცესის რამდენიმე მთავარი ნაბიჯი: 1. შეამოწმეთ, აქვთ თუ არა გრაფებს წვეროებისა და წიბოების ერთნაირი რაოდენობა. 2. შეადარეთ ორივე გრაფის წვეროების ხარისხების მიმდევრობა. 3. მოძებნეთ ერთნაირი სიგრძის ციკლები ორივე გრაფში. 4. შეამოწმეთ მსგავსი ქვეგრაფების არსებობა. თუმცა, ეს პირობები აუცილებელია, მაგრამ არასაკმარისი. იზომორფიზმის დასამტკიცებლად ერთადერთი გზაა წვეროებს შორის ბიექციური ასახვის პოვნა.",
        "exampleDescription": "ქვემოთ მოცემულია ორი იზომორფული გრაფი. მიუხედავად იმისა, რომ ისინი განსხვავებულად გამოიყურებიან, მათ აქვთ ერთნაირი სტრუქტურა.",
        "isomorphicResult": "გრაფები იზომორფულია! მათ აქვთ ერთნაირი სტრუქტურა, მიუხედავად შესაძლო განსხვავებული განლაგებისა ან დასახელებებისა.",
        "nonIsomorphicResult": "გრაფები არ არის იზომორფული. მათ აქვთ განსხვავებული სტრუქტურები.",
        "interactiveDescription": "დააწკაპუნეთ გრაფის არეზე წვეროების დასამატებლად. დააწკაპუნეთ ორ წვეროზე თანმიმდევრობით მათ შორის წიბოს შესაქმნელად. გამოიყენეთ ქვემოთ მოცემული ღილაკები იზომორფიზმის შესამოწმებლად ან უკვე აგებული გრაფების წასაშლელად."
      },
      "spanningTree": {
        "title": "გრაფის დამფარავი ხეები",
        "introduction": "დამფარავი ხე არის გრაფთა თეორიის ფუნდამენტური ცნება, რომელსაც მნიშვნელოვანი გამოყენება აქვს ქსელების დიზაინში, წრედების ანალიზსა და ალგორითმებში. ეს სექცია დაგეხმარებათ გაიგოთ, როგორ მუშაობს დამფარავი ხეები და როგორ ხდება მათი აგება.",
        "definitionTitle": "რა არის დამფარავი ხე?",
        "definition": "არამიმართული გრაფის დამფარავი ხე არის ქვეგრაფი, რომელიც მოიცავს თავდაპირველი გრაფის ყველა წვეროს, მინიმალური რაოდენობის წიბოებით, რაც საჭიროა ხის (აცილკური ბმული გრაფი) შესაქმნელად. სხვა სიტყვებით რომ ვთქვათ, დამფარავი ხე აღწევს ყველა წვეროს ციკლების გარეშე.",
        "algorithmTitle": "როგორ ვიპოვოთ დამფარავი ხე",
        "algorithm": "არსებობს რამდენიმე ალგორითმი დამფარავი ხის საპოვნელად. ერთ-ერთი გავრცელებული მიდგომაა სიგანეში ძებნის (BFS) გამოყენება: 1. დაიწყეთ გრაფის ნებისმიერი წვეროდან. 2. შეისწავლეთ ყველა მოუნახულებელი მეზობელი წვერო. 3. ყოველი მოუნახულებელი მეზობლისთვის, დაამატეთ დამფარავ ხეში წიბო, რომელიც მას აკავშირებს მიმდინარე წვეროსთან. 4. გაიმეორეთ ნაბიჯები 2 და 3 სანამ ყველა წვერო არ იქნება მონახულებული. ეს პროცესი უზრუნველყოფს, რომ მივაღწიოთ ყველა წვეროს მინიმალური რაოდენობის წიბოებით, რაც ქმნის ვალიდურ დამფარავ ხეს.",
        "exampleDescription": "აი, მაგალითი გრაფი გამოყოფილი დამფარავი ხით. ფირუზისფერი წვეროები და ნარინჯისფერი წიბოები წარმოადგენენ დამფარავ ხეს.",
        "exampleExplanation": "ამ მაგალითში გვაქვს გრაფი 8 წვეროთი (A-დან H-მდე) და 12 წიბოთი. გამოყოფილი დამფარავი ხე შეიცავს 7 წიბოს, რაც არის მინიმალური რაოდენობა, რომელიც საჭიროა ყველა 8 წვეროს დასაკავშირებლად ციკლების წარმოქმნის გარეშე. შენიშნეთ, როგორ აღწევს დამფარავი ხე გრაფის ყველა წვეროს, მაგრამ თავდაპირველი გრაფის ზოგიერთი წიბო არ არის დამფარავი ხის ნაწილი. ეს აჩვენებს, თუ როგორ ინარჩუნებს დამფარავი ხე კავშირს გამოყენებული წიბოების რაოდენობის მინიმიზაციის დროს.",
        "interactiveDescription": "ახლა თქვენი ჯერია! დააწკაპუნეთ გრაფის არეზე წვეროების დასამატებლად. დააწკაპუნეთ ორ წვეროზე თანმიმდევრობით მათ შორის წიბოს შესაქმნელად. გამოიყენეთ 'გაშვების' ღილაკი დამფარავი ხის საპოვნელად და 'წაშლის' ღილაკი გრაფის გასასუფთავებლად.",
        "spanningTreeFound": "დამფარავი ხე ნაპოვნია!",
        "spanningTreeFoundDescription": "გრაფის დამფარავი ხე წარმატებით იქნა ნაპოვნი.",
        "spanningTreeNotFound": "დამფარავი ხე ვერ მოიძებნა",
        "spanningTreeNotFoundDescription": "დამფარავი ხე ვერ მოიძებნა. ეს ხდება, როდესაც გრაფი არ არის ბმული (ანუ, არსებობს იზოლირებული წვეროები ან ქვეგრაფები)."
      },
      "graphColoring": {
        "title": "გრაფის გაფერადება",
        "introduction": "გრაფის გაფერადება არის გრაფთა თეორიის ფუნდამენტური ცნება, რომელსაც აქვს მრავალი პრაქტიკული გამოყენება.",
        "definitionTitle": "განმარტება",
        "definition": "გრაფის გაფერადება არის გრაფის წვეროებისთვის ფერების მინიჭება ისე, რომ არცერთი ორი მეზობელი წვერო არ იყოს ერთი და იმავე ფერის.",
        "algorithmTitle": "ალგორითმი",
        "algorithm": "გრაფის გაფერადების მარტივი ხარბი ალგორითმი მუშაობს წვეროების გავლით და ანიჭებს მათ პირველ ხელმისაწვდომ ფერს, რომელიც არ გამოყენებულა მეზობელ წვეროებზე.",
        "exampleDescription": "აი, მარტივი გრაფი, რომელიც აჩვენებს გაფერადების ალგორითმს:",
        "exampleExplanation": "შენიშნეთ, რომ არცერთი დაკავშირებული წვერო არ იზიარებს ერთსა და იმავე ფერს.",
        "interactiveDescription": "ააგეთ საკუთარი გრაფი. დაწკაპუნეთ წვეროს დასამატებლად. დააწკაპუნეთ ორ წვეროზე მათ შორის წიბოს შესაქმნელად. შემდეგ გამოიყენეთ ქვემოთ მოცემული ღილაკები გრაფის გასაფერადებლად ან წასაშლელად.",
        "resultTitle": "გაფერადების შედეგი",
        "resultDescription": "გრაფი წარმატებით გაფერადდა. დააკვირდით, როგორ დაიყვანა მინიმუმამდე ალგორითმმა გამოყენებული ფერების რაოდენობა, ამავდროულად უზრუნველყო, რომ მეზობელ წვეროებს არ ჰქონდეთ ერთი და იგივე ფერი.",
        "usedColors": "გამოყენებული ფერების რაოდენობა: {{count}}"
      }
    },
    "graphProblems": {
      "title": "გრაფთა თეორიის ამოცანები"
    }
  }
}
