{
  "title": "მათემატიკა კომპიუტერული მეცნიერებისთვის",
  "courses": "კურსები",
  "signIn": "შესვლა",
  "signOut": "გასვლა",
  "register": "რეგისტრაცია",
  "introduction_to_logical_operators_title": "შესავალი: ლოგიკური ოპერატორები",
  "calculate": "გამოთვლა",
  "binarySystemTitle": "ორობითი სისტემა",
  "logicalOperandsTitle": "ლოგიკური ოპერატორები",
  "graphTheoryTitle": "გრაფთა თეორია",
  "numberTheoryTitle": "რიცხვთა თეორია",
  "introduction": "შესავალი",
  "lcm-gcd": "უ.ს.ჯ და უ.ს.გ",
  "rsa-algorithm": "RSA ალგორითმი",
  "modular-arithmetic": "მოდულარული არითმეტიკა",
  "quizResults": "ქვიზის შედეგები",
  "question": "შეკითხვა",
  "yourAnswer": "თვქენი პასუხი",
  "correctAnswer": "სწორი პასუხი",
  "totalScore": "ჯამური ქულა",
  "tryAgain": "თავიდან ცდა",
  "correct": "სწორია",
  "incorrect": "არასწორია",
  "decimalValue": "ათობითი მნიშვნელობა",
  "converting": "კონვერტაცია",
  "binaryArithmetic": "ორობითი არითმეტიკა",
  "clickToExplore": "დააწკაპუნეთ, რომ გაეცნოთ კურსს",
  "welcome": "მოგესალმებით",
  "complete": "შესრულებული",
  "result": "შედეგი",
  "wantToTakeQuiz": "გსურთ, რომ შეავსოთ ქვიზი?",
  "viewResults": "შედეგების ნახვა",
  "problems": {
    "selectProblem": "აირჩიეთ ამოცანა",
    "description": "აღწერა:",
    "difficulty": "სირთულე:",
    "task": "დავალება:",
    "inputFormat": "შემომავალი მონაცემების ფორმატი:",
    "outputFormat": "დასაბრუნებელი მონაცემების ფორმატი:",
    "example": "მაგალითი:",
    "note": "შენიშვნა:",
    "chooseLanguage": "აირჩიეთ ენა",
    "language": "ენა",
    "runCode": "გაუშვი კოდი",
    "running": "მიმდინარეობს...",
    "output": "შედეგი:",
    "testCase": "ტესტი",
    "testCaseSuccessful": "წარმატებულია",
    "testCaseFailed": "არაწარმატებულია",
    "expectedResult": "სასურველი შედეგი",
    "gotResult": "ამოხსნის შედეგი",
    "codeAndTestsRunning": "მიმდინარეობს კოდისა და ტესტების გაშვება..."
  },
  "binarySystem": {
    "introduction": {
      "title": "ორობითი სისტემის გაგება",
      "introduction": "ორობითი სისტემა, ასევე ცნობილი როგორც base-2 რიცხვითი სისტემა, ფუნდამენტია კომპიუტერულ მეცნიერებასა და ციფრულ ელექტრონიკაში. ის წარმოადგენს ყველა ციფრული მონაცემის წარმოდგენისა და დამუშავების საფუძველს.",
      "fundamentals": {
        "title": "ორობითის საფუძვლები",
        "description": "ორობითი სისტემა დაფუძნებულია ორ ციფრზე: 0 და 1, ცნობილი როგორც ბიტები (ორობითი ციფრები). აი რამდენიმე ძირითადი პუნქტი:",
        "points": [
          "ორობითი იყენებს მხოლოდ ორ ციფრს ათობითის ათ ციფრთან შედარებით.",
          "თითოეული ციფრის პოზიცია წარმოადგენს 2-ის ხარისხს.",
          "უკიდურესი მარჯვენა ციფრი წარმოადგენს 2^0-ს (1), შემდეგი 2^1-ს (2), შემდეგ 2^2-ს (4) და ა.შ.",
          "ორობით რიცხვებს შეუძლიათ წარმოადგინონ ნებისმიერი რაოდენობა, რასაც ათობითი რიცხვები წარმოადგენენ."
        ]
      },
      "whyBinary": {
        "title": "რატომ გამოიყენება ორობითი კომპიუტერებში",
        "description": "ორობითი არის კომპიუტერების ენა რამდენიმე მიზეზის გამო:",
        "points": [
          "ელექტრონულ სქემებს აქვთ ორი სტაბილური მდგომარეობა, რაც ორობითს ბუნებრივ შესაბამისობას ხდის.",
          "უფრო ადვილი და საიმედოა ორ მდგომარეობას შორის განსხვავების დადგენა, ვიდრე მრავალ მდგომარეობას შორის.",
          "ორობითი ოპერაციები შეიძლება ეფექტურად განხორციელდეს ციფრული ლოგიკის ვენტილებით (Logic Gates).",
          "შეცდომების აღმოჩენა და გასწორება უფრო მარტივია ორობით სისტემაში."
        ]
      },
      "binaryNumbers": {
        "title": "ორობითი რიცხვების გაგება",
        "description": "ორობითი რიცხვები მუშაობს ათობითი რიცხვების მსგავსად, მაგრამ 2-ის ფუძით 10-ის ნაცვლად:",
        "points": [
          "ორობითი რიცხვი 1011 ეკვივალენტურია ათობითი რიცხვის 11 (1*2^3 + 0*2^2 + 1*2^1 + 1*2^0).",
          "ყოველი დამატებითი ბიტი აორმაგებს წარმოდგენილი რიცხვების დიაპაზონს.",
          "8 ბიტს (ბაიტს) შეუძლია წარმოადგინოს რიცხვები 0-დან 255-მდე.",
          "წამყვანი ნულები არ ცვლიან ორობითი რიცხვის მნიშვნელობას."
        ]
      },
      "binaryOperations": {
        "title": "ძირითადი ორობითი ოპერაციები",
        "description": "არითმეტიკა ორობით სისტემაში მიჰყვება მსგავს წესებს, რაც ათობითში, მაგრამ მხოლოდ ორი ციფრით:",
        "points": [
          "შეკრება: 1 + 1 = 10 ორობითში (გადაიტანე 1)",
          "გამოკლება: საჭიროების შემთხვევაში ისესხე შემდეგი სვეტიდან",
          "გამრავლება: მსგავსია ათობითის, მაგრამ უფრო მარტივი, რადგან მხოლოდ 0-ზე ან 1-ზე ამრავლებ",
          "გაყოფა: შეიძლება შესრულდეს განმეორებითი გამოკლებითა და გადაწევით"
        ]
      },
      "applications": {
        "title": "ორობითი სისტემის გამოყენებები",
        "description": "ორობითი სისტემა კრიტიკულად მნიშვნელოვანია კომპიუტინგისა და ტექნოლოგიის მრავალ სფეროში:",
        "points": [
          "მონაცემთა შენახვა: ყველა მონაცემი კომპიუტერებში საბოლოოდ ინახება ორობით ფორმატში.",
          "ციფრული ლოგიკა: კომპიუტერის პროცესორები იყენებენ ორობითს ყველა თავიანთი ოპერაციისთვის.",
          "ქსელური კავშირი: მონაცემთა გადაცემა ქსელებში იყენებს ორობით კოდირებას.",
          "გამოსახულებისა და ხმის დამუშავება: ციფრული მედია წარმოდგენილია და მუშავდება ორობით ფორმატში.",
          "კრიპტოგრაფია: ბევრი დაშიფვრის ალგორითმი ეყრდნობა ორობით ოპერაციებს."
        ]
      }
    },
    "binaryConversion": {
      "title": "ორობითი კონვერტაციის სიღრმისეული გაგება",
      "introduction": "ორობითი კონვერტაცია არის ფუნდამენტური უნარი კომპიუტერულ მეცნიერებასა და ციფრულ სისტემებში. ორობით და ათობით სისტემებს შორის კონვერტაციის პროცესის გაგება კრიტიკულად მნიშვნელოვანია კომპიუტერებთან დაბალ დონეზე მუშაობისთვის.",
      "binaryToDecimal": {
        "title": "ორობითიდან ათობითში გადაყვანა",
        "description": "ორობითი რიცხვის ათობითში გადასაყვანად, უნდა შევაჯამოთ თითოეული ბიტის და მისი შესაბამისი 2-ის ხარისხის ნამრავლები. მარჯვენა უკიდურესი ბიტი შეესაბამება 2^0-ს, შემდეგი 2^1-ს და ა.შ.",
        "example": "მაგალითი: 1011 (ორობითი) = (1 * 2^3) + (0 * 2^2) + (1 * 2^1) + (1 * 2^0) = 8 + 0 + 2 + 1 = 11 (ათობითი)"
      },
      "decimalToBinary": {
        "title": "ათობითიდან ორობითში გადაყვანა",
        "description": "ათობითი რიცხვის ორობითში გადასაყვანად, მრავალჯერადად გავყოთ რიცხვი 2-ზე და ჩავიწეროთ ნაშთები. ორობითი წარმოდგენა არის ნაშთების თანმიმდევრობა ქვემოდან ზემოთ წაკითხვისას.",
        "example": "მაგალითი: 11 (ათობითი) ორობითში:\n11 / 2 = 5 ნაშთი 1\n5 / 2 = 2 ნაშთი 1\n2 / 2 = 1 ნაშთი 0\n1 / 2 = 0 ნაშთი 1\nქვემოდან ზემოთ წაკითხვისას: 1011 (ორობითი)"
      },
      "fractions": {
        "title": "ორობითი წილადები და ათწილადი რიცხვები",
        "description": "ორობითს ასევე შეუძლია წილადი რიცხვების წარმოდგენა. წილადი ნაწილისთვის, მრავალჯერადად გავამრავლოთ 2-ზე, ყოველ ჯერზე მთელი ნაწილის აღება, როგორც შემდეგი ორობითი ციფრი.",
        "example": "მაგალითი: 0.625 (ათობითი) ორობითში:\n0.625 * 2 = 1.25 (1)\n0.25 * 2 = 0.5 (0)\n0.5 * 2 = 1.0 (1)\nშედეგი: 0.101 (ორობითი)"
      },
      "negativeNumbers": {
        "title": "უარყოფითი რიცხვების წარმოდგენა",
        "description": "კომპიუტერები ჩვეულებრივ იყენებენ ორის დამატებას უარყოფითი რიცხვების წარმოსადგენად. რიცხვის ორის დამატების საპოვნელად, შევაბრუნოთ ყველა ბიტი და დავუმატოთ 1.",
        "example": "მაგალითი: -5 8-ბიტიან ორის დამატებაში:\n5 ორობითში: 00000101\nყველა ბიტის შებრუნება: 11111010\n1-ის დამატება: 11111011\nამრიგად, -5 წარმოდგენილია როგორც 11111011 ორის დამატებაში"
      },
      "applications": {
        "title": "პრაქტიკული გამოყენებები",
        "description": "ორობითი კონვერტაციის გაგება კრიტიკულად მნიშვნელოვანია კომპიუტინგის მრავალ სფეროში:",
        "list": [
          "ციფრული სქემების დიზაინი და ანალიზი",
          "დაბალი დონის პროგრამირება და ჩაშენებული სისტემები",
          "ქსელის პროტოკოლები და მონაცემთა გადაცემა",
          "კრიპტოგრაფია და მონაცემთა უსაფრთხოება",
          "კომპიუტერული გრაფიკა და გამოსახულების დამუშავება"
        ]
      },
      "advancedTopics": {
        "title": "გაღრმავებული ორობითი თემები",
        "description": "ძირითადი კონვერტაციის გარდა, არსებობს რამდენიმე გაღრმავებული თემა, დაკავშირებული ორობით წარმოდგენასთან:",
        "list": [
          "IEEE 754 ათწილადის წარმოდგენა",
          "ორობით-კოდირებული ათობითი (BCD)",
          "გრეის კოდი და მისი გამოყენებები",
          "თექვსმეტობითი, როგორც ორობითის კომპაქტური წარმოდგენა",
          "შეცდომების აღმოჩენისა და გასწორების კოდები (მაგ., ჰემინგის კოდები)"
        ]
      },
      "calculator": {
        "binary": "ორობითი",
        "decimal": "ათობითი",
        "enterBinaryNumber": "შეიყვანეთ ორობითი რიცხვი",
        "enterDecimalNumber": "შეიყვანეთ ათობითი რიცხვი"
      }
    },
    "binaryArithmetic": {
      "title": "გაღრმავებული ორობითი არითმეტიკა",
      "introduction": "ორობითი არითმეტიკა მუშაობს ათობითი არითმეტიკის მსგავსად, მაგრამ მიჰყვება ორობითი რიცხვითი სისტემის წესებს. ამ ოპერაციების გაგება მნიშვნელოვანია დაბალი დონის პროგრამირებისა და კომპიუტერის არქიტექტურისთვის.",
      "addition": {
        "title": "ორობითი შეკრება",
        "description": "ორობითი შეკრება ათობითი შეკრების მსგავსია, მაგრამ მხოლოდ ორი ციფრით. მთავარია გვახსოვდეს, რომ 1 + 1 ორობითში უდრის 10-ს (2-ს ათობითში).",
        "table": [
          {
            "A": "0",
            "B": "0",
            "ჯამი": "0",
            "გადატანა": "0"
          },
          {
            "A": "0",
            "B": "1",
            "ჯამი": "1",
            "გადატანა": "0"
          },
          {
            "A": "1",
            "B": "0",
            "ჯამი": "1",
            "გადატანა": "0"
          },
          {
            "A": "1",
            "B": "1",
            "ჯამი": "0",
            "გადატანა": "1"
          }
        ],
        "example": "მაგალითი: 1011-ისა და 1101-ის შეკრება\n  1011\n+ 1101\n------\n 10100"
      },
      "subtraction": {
        "title": "ორობითი გამოკლება",
        "description": "ორობითი გამოკლება მიჰყვება ათობითი გამოკლების მსგავს პრინციპებს, საჭიროების შემთხვევაში სესხებით.",
        "table": [
          {
            "A": "0",
            "B": "0",
            "სხვაობა": "0",
            "სესხი": "0"
          },
          {
            "A": "0",
            "B": "1",
            "სხვაობა": "1",
            "სესხი": "1"
          },
          {
            "A": "1",
            "B": "0",
            "სხვაობა": "1",
            "სესხი": "0"
          },
          {
            "A": "1",
            "B": "1",
            "სხვაობა": "0",
            "სესხი": "0"
          }
        ],
        "example": "მაგალითი: 1011-ის გამოკლება 1101-დან\n  1101\n- 1011\n------\n  0010"
      },
      "multiplication": {
        "title": "ორობითი გამრავლება",
        "description": "ორობითი გამრავლება უფრო მარტივია ვიდრე ათობითი გამრავლება, რადგან მხოლოდ 0-ებსა და 1-ებს მოიცავს.",
        "table": [
          {
            "A": "0",
            "B": "0",
            "ნამრავლი": "0"
          },
          {
            "A": "0",
            "B": "1",
            "ნამრავლი": "0"
          },
          {
            "A": "1",
            "B": "0",
            "ნამრავლი": "0"
          },
          {
            "A": "1",
            "B": "1",
            "ნამრავლი": "1"
          }
        ],
        "example": "მაგალითი: 101-ის გამრავლება 11-ზე\n  101\n×  11\n-----\n  101\n 101\n-----\n 1111"
      },
      "division": {
        "title": "ორობითი გაყოფა",
        "description": "ორობითი გაყოფა მიჰყვება ათობითი გაყოფის იმავე პრინციპებს, მაგრამ იყენებს ორობით რიცხვებს.",
        "example": "მაგალითი: 1010-ის გაყოფა 10-ზე\n  101\n-------\n10 | 1010\n    - 10\n    ----\n      10\n     -10\n    ----\n       0"
      },
      "advancedTopics": {
        "title": "გაღრმავებული ორობითი არითმეტიკის კონცეფციები",
        "description": "ძირითადი ოპერაციების გარდა, არსებობს რამდენიმე გაღრმავებული თემა ორობით არითმეტიკაში:",
        "list": [
          "ორის შევსების წარმოდგენა ნიშნიანი მთელი რიცხვებისთვის",
          "ათწილადი რიცხვების არითმეტიკა (IEEE 754 სტანდარტი)",
          "ბიტური ოპერაციები (AND, OR, XOR, NOT)",
          "არითმეტიკული და ლოგიკური წანაცვლებები",
          "მიმდევრობითი გადატანის შემკრები და სხვა სწრაფი შეკრების ტექნიკები",
          "ბუთის გამრავლების ალგორითმი",
          "არააღდგენითი გაყოფის ალგორითმი"
        ]
      },
      "applications": {
        "title": "ორობითი არითმეტიკის გამოყენებები",
        "description": "ორობითი არითმეტიკა ფუნდამენტურია კომპიუტინგის მრავალ სფეროში:",
        "list": [
          "ALU-ს (არითმეტიკულ-ლოგიკური მოწყობილობა) დიზაინი პროცესორებში",
          "ათწილადების თანაპროცესორები",
          "ციფრული სიგნალების დამუშავება",
          "კრიპტოგრაფიული ალგორითმები",
          "შეცდომების აღმოჩენისა და გასწორების კოდები",
          "კომპიუტერული გრაფიკა (მაგ., მატრიცული ოპერაციები)",
          "მანქანური სწავლების აქსელერატორები"
        ]
      },
      "calculator": {
        "enterFirstBinary": "შეიყვანეთ პირველი ორობითი რიცხვი",
        "enterSecondBinary": "შეიყვანეთ მეორე ორობითი რიცხვი"
      }
    }
  },
  "logicalOperands": {
    "title": "ლოგიკური ოპერატორები",
    "introduction": {
      "title": "შესავალი",
      "description": "ლოგიკური ოპერატორები ფუნდამენტური თემაა დისკრეტულ მათემატიკასა და კომპიუტერულ მეცნიერებებში. მათი გამოყენება საშუალებას გვაძლევენ ავაგოთ რთული პირობები და განვსაზღვროთ გადაწყვეტილებები პროგრამაში მიმდინარე პროცესებში.",
      "moduleExploration": {
        "header": "ამ კურსში, თქვენ გაეცნობით შემდეგ თემებს:",
        "items": [
          "მარტივი ლოგიკური ოპერატორები",
          "რთული ლოგიკური ოპერატორები",
          "ჭეშმარიტების ცხრილები"
        ]
      },
      "understandingImportance": {
        "header": "ლოგიკური ოპერატორების მნიშვნელობა",
        "items": [
          "ისინი აუცილებელია პროგრამირებაში პირობების განსაზღვრისა და პროგრამის მიმდინარეობის კონტროლისათვის.",
          "ისინი წარმოადგენენ კომპიუტერული სქემების დიზაინის საფუძველს.",
          "ისინი ფართოდ გამოიყენება მონაცემთა ბაზებზე კომპლექსური ძიების გასაშვებად.",
          "ისინი მნიშვნელოვან როლს ასრულებენ ხელოვნური ინტელექტის სისტემებში, განსაკუთრებით გადაწყვეტილების მიღების ალგორითმებში."
        ]
      },
      "realLifeExamples": {
        "header": "ლოგიკური ოპერატორები ყოველდღიურ ცხოვრებაში",
        "description": "ლოგიკური ოპერატორების თემა არ არის მხოლოდ კომპიუტერული ცნება. ის გვხვდება ჩვენს ყოველდღიურ გადაწყვეტილებებშიც. მოდით, განვიხილოთ მარტივი მაგალითი ნათურის ჩამრთველებით:",
        "lightSwitchExample": {
          "title": "ნათურის ჩამრთველების მაგალითი",
          "description": "წარმოიდგინეთ, რომ გაქვთ ოთახი ორი ჩამრთველით. თითოეული ჩამრთველი შეიძლება იყოს ჩართული ან გამორთული. შემოვიტანოთ ორი ლოგიკური ოპერატორი: და, ან. განვიხილოთ ისინი მაგალითებით.",
          "andOperatorName": "და",
          "andOperator": " - ნათურა აინთება მხოლოდ მაშინ, როცა ორივე ჩამრთველი ჩართულია.",
          "orOperatorName": "ან",
          "orOperator": " - ნათურა აინთება, თუ ერთ-ერთი ჩამრთველი მაინც ჩართულია."
        }
      },
      "progressNote": "ამ კურსში წინსვლისას, თქვენ მოიპოვებთ მყარ ცოდნას ლოგიკური ოპერატორების მიმართულებით, რაც მოგამზადებთ კომპიუტერულ მეცნიერებასა და დისკრეტულ მათემატიკაში უფრო რთული თემებისთვის."
    },
    "basicOperators": {
      "title": "მარტივი ლოგიკური ოპერატორები",
      "introduction": "მოგესალმებით ლოგიკური ოპერატორების სამყაროში! ისინი გადაწყვეტილების მიღების საფუძველია როგორც პროგრამირებაში, ასევე ყოველდღიურ ცხოვრებაში. როგორც შუქნიშნები მართავენ მანქანების მოძრაობას გზაზე, ასევე ლოგიკური ოპერატორები მართავენ ჩვენი პროგრამების მუშაობის მიმდინარეობას. ისინი გვეხმარებიან მივიღოთ გადაწყვეტილებები სხვადასხვა პირობების საფუძველზე, რაც საშუალებას აძლევს ჩვენს კოდს \"იფიქროს\" და \"იმოქმედოს\". მოდით ვნახოთ, როგორ აყალიბებენ მარტივი ლოგიკური ოპერატორები ჩვენს გარშემო არსებულ ციფრულ სამყაროს!",
      "interactionPrompt": "მოდით, ვცადოთ! დააწკაპუნეთ ქვემოთ მოცემულ ბიტებზე 0-სა (მცდარი) და 1-ს (ჭეშმარიტი) შორის გადასართველად. დააკვირდით, როგორ რეაგირებს თითოეული ოპერატორი თქვენს არჩევანზე!",
      "and": {
        "title": "და: პერფექციონისტი",
        "description": "\"და\" ოპერატორი მკაცრ მასწავლებელს ჰგავს - ის მხოლოდ მაშინ გაძლევთ დადებით შეფასებას (აბრუნებს ჭეშმარიტს ან 1-ს), როცა ყველა პირობა შესრულებულია. თუ რომელიმე პირობა ვერ სრულდება, შედეგი უარყოფითია (მცდარი ან 0).",
        "explanation": "წარმოიდგინეთ, რომ იდეალურ პიკნიკს გეგმავთ. თქვენ წახვალთ მხოლოდ იმ შემთხვევაში, თუ მზიანი ამინდია \"და\" თქვენ გაქვთ თავისუფალი დრო \"და\" თქვენი კალათა სავსეა საგზლით. \"და\" ოპერატორი პროგრამირებაში იგივე პრინციპით მუშაობს. ის ამოწმებს, არის თუ არა ყველა პირობა ჭეშმარიტი, ისევე როგორც თქვენ ამოწმებთ თქვენი პიკნიკისთვის სიის ყველა პუნქტს. ეს იდეალურია ისეთი სიტუაციებისთვის, სადაც ყველა პირობა ზუსტად უნდა დაემთხვეს!",
        "symbol": "&&"
      },
      "or": {
        "title": "ან: მოქნილი მეგობარი",
        "description": "\"ან\" ოპერატორი ლმობიერ მშობელს ჰგავს - თუ რომელიმე პირობა მაინც სრულდება (ჭეშმარიტია ან 1), ის კმაყოფილებას გამოხატავს. ის მხოლოდ მაშინ აბრუნებს მცდარს (0), როცა არცერთი პირობა არ სრულდება.",
        "explanation": "წარმოიდგინეთ \"ან\", როგორც თქვენი შაბათ-კვირის გეგმები. თქვენ კმაყოფილი იქნებით, თუ შეძლებთ ფილმის ყურებას \"ან\" მეგობრებთან ერთად დროის გატარებას \"ან\" კარგი წიგნის წაკითხვას. ნებისმიერი მათგანი კარგი დროის გატარებაა! პროგრამირებაში \"ან\" გვეხმარება შევქმნათ მოქნილი პირობები. ის შესანიშნავია, როდესაც გვაქვს რამდენიმე მისაღები ვარიანტი და ნებისმიერი მათგანი საკმარისია პროგრამის გასაგრძელებლად.",
        "symbol": "||"
      },
      "not": {
        "title": "არა: მეამბოხე",
        "description": "\"არა\" ოპერატორი ამ ჯგუფის მეამბოხეა - ის ყოველთვის საპირისპიროს აკეთებს. ის ჭეშმარიტს აქცევს მცდარად და მცდარს - ჭეშმარიტად.",
        "explanation": "წარმოიდგინეთ ცელქი და-ძმა, რომელიც ყოველთვის საწინააღმდეგოს აკეთებს იმისა, რასაც ეუბნებით. თუ ეტყვით 'არ შეეხო ამას', ისინი აუცილებლად შეეხებიან. ზუსტად ასე მუშაობს \"არა\" ოპერატორი. ეს ძალიან სასარგებლოა, როდესაც გინდათ შეამოწმოთ, რომ რაღაც არ არის ჭეშმარიტი. მაგალითად, იმის შემოწმება, რომ მომხმარებელი არ არის შესული სისტემაში, რათა აჩვენოთ მას შესვლის ღილაკი. \"არა\" გვეხმარება ჩვენი ლოგიკა თავდაყირა დავაყენოთ, როცა ეს გვჭირდება!",
        "symbol": "!"
      },
      "xor": {
        "title": "გამომრიცხავი ან(XOR): ექსკლუზიური გადაწყვეტილების მიმღები",
        "description": "XOR პრეტენზიულ მჭამელს ჰგავს - ის მხოლოდ მაშინ არის კმაყოფილი (აბრუნებს ჭეშმარიტს), როდესაც ზუსტად ერთი ვარიანტია ხელმისაწვდომი, არა ორივე და არც არცერთი.",
        "explanation": "წარმოიდგინეთ, რომ არდადეგებზე წასვლას გეგმავთ: ზღვაზე ან მთაში. XOR ისე მოქმედებს, როგორც ნათქვამი: 'მინდა წავიდე ან ზღვაზე, ან მთებში, მაგრამ არა ორივეგან ერთად!' ის ჭეშმარიტია, როცა ერთი ვარიანტი ჭეშმარიტია, ხოლო მეორე - მცდარი. პროგრამირებაში XOR შესანიშნავია როდესაც გჭირდებათ დარწმუნდეთ, რომ ორი პირობიდან ზუსტად ერთი სრულდება, მაგრამ არასდროს ორივე ერთად.",
        "symbol": "⊕"
      },
      "truthTables": {
        "title": "ჭეშმარიტების ცხრილი",
        "tableHeaderA": "პირობა A",
        "tableHeaderB": "პირობა B",
        "tableHeaderResult": "საბოლოო შედეგი"
      },
      "logicalOperatorGame": {
        "title": "ლოგიკური ოპერატორების თამაში",
        "introduction": "შეამოწმეთ თქვენი უნარები „და“, „ან“ და „არა“ ოპერატორების გარშემო. რამდენ სწორ პასუხს დააგროვებთ 30 წამში?",
        "time": "დრო",
        "score": "ქულა",
        "gameOver": "თამაში დასრულებულია!",
        "finalScore": "საბოლოო ქულა",
        "startGame": "თამაშის დაწყება",
        "playAgain": "სცადე თავიდან",
        "true": "ჭეშმარიტი",
        "false": "მცდარი"
      }
    },
    "advancedOperators": {
      "title": "რთული ლოგიკური ოპერატორები",
      "introduction": "მოგესალმებით რთული ლოგიკური ოპერატორების სამყაროში! ისინი ეფუძნებიან ძირითად ოპერატორებს და ქმნიან უფრო კომპლექსურ გადაწყვეტილების მიღების სტრუქტურებს პროგრამირებაში. როგორც შეფ-მზარეულები აერთიანებენ ინგრედიენტებს, ეს ოპერატორები ურევენ ძირითად ლოგიკურ ოპერატორებს რთული შედეგების მისაღებად. მოდით, ვნახოთ, როგორ ამდიდრებენ ისინი ჩვენს ლოგიკურ სამყაროს!",
      "interactionPrompt": "მოდით, ვცადოთ! დააწკაპუნეთ ქვემოთ მოცემულ ბიტებზე 0-სა (მცდარი) და 1-ს (ჭეშმარიტი) შორის გადასართველად. დააკვირდით, როგორ ამუშავებს თითოეული ოპერატორი თქვენს შეყვანილ მონაცემებს!",
      "nand": {
        "title": "NAND: უნივერსალური უარმყოფელი",
        "description": "NAND ოპერატორი ჰგავს ოპოზიციონერთა კომიტეტს - ის მხოლოდ მაშინ აბრუნებს მცდარს, როცა ყველა პირობა ჭეშმარიტია. ყველა სხვა შემთხვევაში ის აბრუნებს ჭეშმარიტს.",
        "explanation": "წარმოიდგინეთ მეგობრების ჯგუფი, რომელიც ფილმის არჩევანზე მსჯელობს. NAND-ით, თქვენ მხოლოდ მაშინ დარჩებით სახლში, თუ ყველა ერთსა და იმავე ფილმზე შეთანხმდება. ნებისმიერი უთანხმოება და თქვენ ფილმის სანახავად წახვალთ! ელექტრულ სქემებში NAND განსაკუთრებულია, რადგან მისი გამოყენებით შესაძლებელია ყველა სხვა ლოგიკური ოპერაციის შექმნა, რაც მას მრავალმხრივ სამშენებლო ბლოკად აქცევს.",
        "symbol": "⊼"
      },
      "nor": {
        "title": "NOR: უნივერსალური პესიმისტი",
        "description": "NOR ოპერატორი ჰგავს უკიდურეს კრიტიკოსს - ის მხოლოდ მაშინ აბრუნებს ჭეშმარიტს, როცა ყველა პირობა მცდარია. თუ რომელიმე პირობა ჭეშმარიტია, ის აბრუნებს მცდარს.",
        "explanation": "წარმოიდგინეთ NOR, როგორც გულფიცხი მჭამელი კაფეტერიაში. ის მხოლოდ მაშინ იქნება კმაყოფილი (დააბრუნებენ ჭეშმარიტს), თუ არცერთი კერძი არ მოეწონებათ. თუ თუნდაც ერთი კერძი კარგად გამოიყურება, ისინი უკმაყოფილონი არიან. ციფრულ ლოგიკაში NOR ოპერატორი განსაკუთრებულია, რადგან NAND-ის მსგავსად, მისი გამოყენებით შესაძლებელია ყველა სხვა ლოგიკური ოპერაციის აგება.",
        "symbol": "⊽"
      },
      "xor": {
        "title": "გამომრიცხავი ან(XOR): ექსკლუზიური გადაწყვეტილების მიმღები",
        "description": "XOR პრეტენზიულ მჭამელს ჰგავს - ის მხოლოდ მაშინ არის კმაყოფილი (აბრუნებს ჭეშმარიტს), როდესაც ზუსტად ერთი ვარიანტია ხელმისაწვდომი, არა ორივე და არც არცერთი.",
        "explanation": "წარმოიდგინეთ, რომ არდადეგებზე წასვლას გეგმავთ: ზღვაზე ან მთაში. XOR ისე მოქმედებს, როგორც ნათქვამი: 'მინდა წავიდე ან ზღვაზე, ან მთებში, მაგრამ არა ორივეგან ერთად!' ის ჭეშმარიტია, როცა ერთი ვარიანტი ჭეშმარიტია, ხოლო მეორე - მცდარი. პროგრამირებაში XOR შესანიშნავია როდესაც გჭირდებათ დარწმუნდეთ, რომ ორი პირობიდან ზუსტად ერთი სრულდება, მაგრამ არასდროს ორივე ერთად.",
        "symbol": "⊕"
      },
      "truthTables": {
        "title": "ჭეშმარიტების ცხრილი",
        "tableHeaderA": "პირობა A",
        "tableHeaderB": "პირობა B",
        "tableHeaderResult": "შედეგი"
      },
      "advancedLogicalOperatorGame": {
        "title": "ლოგიკური ოპერატორების თამაში",
        "introduction": "შეამოწმეთ თქვენი ოსტატობა NAND, NOR და XOR ოპერატორებში. რამდენ ამოცანას გადაჭრით 30 წამში?",
        "time": "დრო",
        "score": "ქულა",
        "gameOver": "გამოწვევა დასრულებულია!",
        "finalScore": "საბოლოო ქულა",
        "startGame": "გამოწვევის დაწყება",
        "playAgain": "ხელახლა ცდა",
        "true": "ჭეშმარიტი",
        "false": "მცდარი"
      }
    }
  },
  "numberTheory": {
    "introduction": {
      "title": "შესავალი რიცხვთა თეორიაში",
      "description": "რიცხვთა თეორია არის წმინდა მათემატიკის დარგი, რომელიც ძირითადად ეძღვნება მთელი რიცხვებისა და მთელრიცხვა ფუნქციების შესწავლას. ეს არის მათემატიკის ერთ-ერთი უძველესი და ფუნდამენტური სფერო, მდიდარი ისტორიით, რომელიც უძველეს ცივილიზაციებამდე მიდის.",
      "keyConcepts": {
        "title": "ძირითადი კონცეფციები რიცხვთა თეორიაში:",
        "list": [
          "მარტივი რიცხვები: 1-ზე მეტი რიცხვები, რომლებსაც არ აქვთ სხვა დადებითი გამყოფები გარდა 1-ისა და საკუთარი თავისა.",
          "გაყოფადობა: იმის შესწავლა, თუ როდის არის ერთი მთელი რიცხვი გაყოფადი მეორეზე.",
          "უდიდესი საერთო გამყოფი (უსგ): უდიდესი დადებითი მთელი რიცხვი, რომელიც ყოფს თითოეულ რიცხვს ნაშთის გარეშე.",
          "უმცირესი საერთო ჯერადი (უსჯ): უმცირესი დადებითი მთელი რიცხვი, რომელიც იყოფა თითოეულ რიცხვზე.",
          "მოდულური არითმეტიკა: არითმეტიკა, რომელიც ეხება ნაშთებს გაყოფის შემდეგ.",
          "დიოფანტური განტოლებები: პოლინომიალური განტოლებები, სადაც მხოლოდ მთელრიცხვა ამონახსნები იძებნება."
        ]
      },
      "applications": {
        "title": "რიცხვთა თეორიის გამოყენებები:",
        "list": [
          "კრიპტოგრაფია: ბევრი დაშიფვრის მეთოდი, მათ შორის RSA, დაფუძნებულია რიცხვთა თეორიის პრინციპებზე.",
          "კომპიუტერული მეცნიერება: ალგორითმები, მონაცემთა სტრუქტურები და შეცდომების გასწორების კოდები ხშირად ეყრდნობა რიცხვთა თეორიის კონცეფციებს.",
          "ფიზიკა: რიცხვთა თეორია გამოიყენება თეორიული ფიზიკის სხვადასხვა სფეროში, მათ შორის სიმების თეორიაში.",
          "ინჟინერია: გამოყენებები სიგნალების დამუშავებაში, მართვის თეორიაში და სხვა საინჟინრო სფეროებში."
        ]
      },
      "conclusion": "რიცხვთა თეორია კვლავ რჩება კვლევის აქტიურ სფეროდ, ბევრი გადაუჭრელი პრობლემითა და ჰიპოთეზით, რომლებმაც საუკუნეების მანძილზე დააბნიეს მათემატიკოსები."
    },
    "lcmAndGcd": {
      "title": "უმცირესი საერთო ჯერადი (უსჯ) და უდიდესი საერთო გამყოფი (უსგ)",
      "whatAre": {
        "title": "რა არის უსჯ და უსგ?",
        "lcm": {
          "title": "უმცირესი საერთო ჯერადი (უსჯ)",
          "description": "ორი ან მეტი მთელი რიცხვის უსჯ არის უმცირესი დადებითი მთელი რიცხვი, რომელიც იყოფა თითოეულ ამ რიცხვზე. მაგალითად, 4-ისა და 6-ის უსჯ არის 12."
        },
        "gcd": {
          "title": "უდიდესი საერთო გამყოფი (უსგ)",
          "description": "ორი ან მეტი მთელი რიცხვის უსგ არის უდიდესი დადებითი მთელი რიცხვი, რომელიც ყოფს თითოეულ ამ რიცხვს ნაშთის გარეშე. მაგალითად, 8-ისა და 12-ის უსგ არის 4."
        }
      },
      "importance": {
        "title": "რატომ არის მნიშვნელოვანი უსჯ და უსგ?",
        "list": [
          "უსჯ გამოიყენება მათემატიკის მრავალ სფეროში, მათ შორის წილადებში, ალგებრაში და რიცხვთა თეორიაში.",
          "უსგ ფუნდამენტურია წილადების გამარტივებაში, დიოფანტური განტოლებების ამოხსნაში და კომპიუტერულ მეცნიერებაში სხვადასხვა ალგორითმებში.",
          "როგორც უსჯ, ისე უსგ მნიშვნელოვანია კრიპტოგრაფიაში, განსაკუთრებით RSA ალგორითმში.",
          "კომპიუტერულ პროგრამირებაში, უსჯ და უსგ გამოიყენება სხვადასხვა ალგორითმებსა და მონაცემთა სტრუქტურებში."
        ]
      },
      "calculation": {
        "title": "როგორ გამოვთვალოთ უსჯ და უსგ",
        "gcd": {
          "title": "უსგ-ს გამოთვლა",
          "description": "უსგ-ს გამოსათვლელად ყველაზე ეფექტური მეთოდია ევკლიდეს ალგორითმი:",
          "steps": [
            "გაყავით დიდი რიცხვი პატარაზე.",
            "შეცვალეთ დიდი რიცხვი პატარა რიცხვით, ხოლო პატარა რიცხვი - პირველი ნაბიჯის ნაშთით.",
            "გაიმეორეთ, სანამ ნაშთი არ გახდება ნული. ბოლო არანულოვანი ნაშთი არის უსგ."
          ]
        },
        "lcm": {
          "title": "უსჯ-ს გამოთვლა",
          "description": "უსჯ შეიძლება გამოითვალოს შემდეგი ფორმულით:",
          "formula": "უსჯ(a, b) = |a * b| / უსგ(a, b)",
          "note": "სადაც |a * b| აღნიშნავს a * b-ს აბსოლუტურ მნიშვნელობას."
        }
      },
      "examples": {
        "title": "მაგალითები",
        "gcd": {
          "title": "უსგ-ს მაგალითი: გამოვთვალოთ უსგ(48, 18)",
          "steps": [
            "48 ÷ 18 = 2 ნაშთი 12",
            "18 ÷ 12 = 1 ნაშთი 6",
            "12 ÷ 6 = 2 ნაშთი 0",
            "ბოლო არანულოვანი ნაშთი არის 6, ამიტომ უსგ(48, 18) = 6"
          ]
        },
        "lcm": {
          "title": "უსჯ-ს მაგალითი: გამოვთვალოთ უსჯ(12, 18)",
          "steps": [
            "ჯერ გამოვთვალოთ უსგ(12, 18) = 6",
            "შემდეგ, უსჯ(12, 18) = |12 * 18| / 6 = 216 / 6 = 36"
          ]
        }
      },
      "calculator": {
        "enterFirstNumber": "შეიყვანეთ პირველი რიცხვი",
        "enterSecondNumber": "შეიყვანეთ მეორე რიცხვი",
        "lcm": "უ.ს.ჯ",
        "gcd": "უ.ს.გ"
      }
    },
    "modularArithmetic": {
      "title": "მოდულარული არითმეტიკა",
      "introduction": {
        "title": "რა არის მოდულარული არითმეტიკა?",
        "description": "მოდულარული არითმეტიკა არის არითმეტიკული სისტემა მთელი რიცხვებისთვის, სადაც რიცხვები \"ბრუნდება\" გარკვეული მნიშვნელობის - მოდულის მიღწევის შემდეგ. ის ხშირად აღწერილია როგორც \"საათის არითმეტიკა\", რადგან ის ჰგავს საათზე საათების 12-დან 1-ზე გადასვლას."
      },
      "keyConcepts": {
        "title": "ძირითადი კონცეფციები",
        "list": [
          "კონგრუენტულობა: ვამბობთ, რომ a კონგრუენტულია b-სთან მოდულით m, თუ m ყოფს (a-b)-ს. ჩვენ ამას ვწერთ როგორც a ≡ b (mod m).",
          "მოდულარული შეკრება: (a + b) mod m = ((a mod m) + (b mod m)) mod m",
          "მოდულარული გამოკლება: (a - b) mod m = ((a mod m) - (b mod m) + m) mod m",
          "მოდულარული გამრავლება: (a * b) mod m = ((a mod m) * (b mod m)) mod m",
          "მოდულარული ახარისხება: a^b mod m = ((a mod m)^b) mod m"
        ]
      },
      "applications": {
        "title": "გამოყენებები",
        "description": "მოდულარულ არითმეტიკას აქვს მრავალი გამოყენება კომპიუტერულ მეცნიერებასა და კრიპტოგრაფიაში:",
        "list": [
          "ჰეშ ფუნქციები",
          "შემთხვევითი რიცხვების გენერაცია",
          "შეცდომების აღმოჩენისა და გასწორების კოდები",
          "კრიპტოგრაფიული ალგორითმები (როგორიცაა RSA)"
        ]
      },
      "calculator": {
        "title": "მოდულარული არითმეტიკის კალკულატორი",
        "result": "შედეგი: {{a}} {{operation}} {{b}} ≡ {{result}} (mod {{m}})"
      }
    },
    "rsaAlgorithm": {
      "title": "RSA ალგორითმი",
      "whatIsRSA": {
        "title": "რა არის RSA?",
        "description1": "RSA (Rivest-Shamir-Adleman) არის საჯარო გასაღების კრიპტოსისტემა, რომელიც ფართოდ გამოიყენება უსაფრთხო მონაცემთა გადაცემისთვის. ეს არის ასიმეტრიული კრიპტოგრაფიული ალგორითმი, რაც ნიშნავს, რომ იგი იყენებს ორ სხვადასხვა გასაღებს: საჯარო გასაღებს დაშიფვრისთვის და პირად გასაღებს გაშიფვრისთვის.",
        "description2": "RSA პირველად აღწერეს 1977 წელს რონ რივესტმა, ადი შამირმა და ლეონარდ ადლემანმა MIT-ში. ასოები RSA არის მათი გვარების ინიციალები. ეს იყო ერთ-ერთი პირველი პრაქტიკული საჯარო გასაღების კრიპტოსისტემა და კვლავ ფართოდ გამოიყენება უსაფრთხო მონაცემთა გადაცემისთვის."
      },
      "importance": {
        "title": "RSA-ს მნიშვნელობა",
        "list": [
          "უსაფრთხოება: RSA-ს უსაფრთხოება ეფუძნება ორი დიდი მარტივი რიცხვის ნამრავლის ფაქტორიზაციის პრაქტიკულ სირთულეს, რაც ცნობილია როგორც ფაქტორიზაციის პრობლემა.",
          "ციფრული ხელმოწერები: RSA შეიძლება გამოყენებულ იქნას ციფრული ხელმოწერების შესაქმნელად, რაც უზრუნველყოფს ციფრული შეტყობინებების ან დოკუმენტების ავთენტურობასა და მთლიანობას.",
          "გასაღების გაცვლა: იგი საშუალებას იძლევა უსაფრთხოდ გაცვალოთ გასაღებები არაუსაფრთხო არხებზე, რაც მნიშვნელოვანია უსაფრთხო კომუნიკაციის დამყარებისთვის.",
          "ფართო გამოყენება: RSA გამოიყენება მრავალ პროტოკოლში, მათ შორის SSL/TLS-ში, რომელიც გამოიყენება ინტერნეტ კომუნიკაციების დასაცავად."
        ]
      },
      "howItWorks": {
        "title": "როგორ მუშაობს RSA: დეტალური ნაბიჯები",
        "keyGeneration": {
          "title": "1. გასაღების გენერაცია:",
          "steps": [
            "აირჩიეთ ორი განსხვავებული დიდი მარტივი რიცხვი p და q.",
            "გამოთვალეთ n = p * q. ეს n იწოდება მოდულად როგორც საჯარო, ისე პირადი გასაღებებისთვის.",
            "გამოთვალეთ φ(n) = (p-1) * (q-1). ეს არის ეილერის ფუნქცია.",
            "აირჩიეთ მთელი რიცხვი e ისე, რომ 1 < e < φ(n) და gcd(e, φ(n)) = 1. ეს e არის საჯარო ექსპონენტი.",
            "გამოთვალეთ d როგორც e-ს მოდულარული მულტიპლიკაციური შებრუნება (mod φ(n)). ეს d არის პირადი ექსპონენტი."
          ]
        },
        "keyDistribution": {
          "title": "2. გასაღების განაწილება:",
          "steps": [
            "საჯარო გასაღებია (e, n). ეს შეიძლება ცნობილი იყოს ყველასთვის და გამოიყენება დაშიფვრისთვის.",
            "პირადი გასაღებია (d, n). ეს უნდა იყოს საიდუმლოდ შენახული და გამოიყენება გაშიფვრისთვის."
          ]
        },
        "encryption": {
          "title": "3. დაშიფვრა:",
          "steps": [
            "გადაიყვანეთ შეტყობინება რიცხვში m, სადაც 0 ≤ m < n.",
            "გამოთვალეთ შიფროტექსტი c = m^e mod n."
          ]
        },
        "decryption": {
          "title": "4. გაშიფვრა:",
          "steps": [
            "გამოიყენეთ პირადი გასაღები (d, n) m-ის გამოსათვლელად: m = c^d mod n.",
            "გადაიყვანეთ m უკან ორიგინალ შეტყობინებაში."
          ]
        }
      },
      "mathematicalFoundation": {
        "title": "მათემატიკური საფუძველი",
        "description": "RSA-ს უსაფრთხოება ეფუძნება ორ მათემატიკურ ფაქტს:",
        "fact1": "1. მოდულარული ახარისხება: გამოთვლითად ადვილია n = p * q და c = m^e mod n გამოთვლა.",
        "fact2": "2. მარტივ მამრავლებად დაშლა: გამოთვლითად რთულია p-ს და q-ს განსაზღვრა n-დან, განსაკუთრებით მაშინ, როცა p და q დიდი მარტივი რიცხვებია.",
        "additional": "ალგორითმი ასევე ეყრდნობა ეილერის თეორემას და მოდულარული არითმეტიკის თვისებებს, რათა უზრუნველყოს, რომ დაშიფვრა და გაშიფვრა არიან შებრუნებული ოპერაციები."
      },
      "securityConsiderations": {
        "title": "უსაფრთხოების მოსაზრებები",
        "list": [
          "გასაღების ზომა: RSA-ს უსაფრთხოება დამოკიდებულია n-ის ზომაზე. 2021 წლის მდგომარეობით, 2048 ბიტის ზომის გასაღები ითვლება უსაფრთხოდ უმეტესი გამოყენებისთვის.",
          "მარტივი რიცხვების გენერაცია: მარტივი რიცხვები p და q უნდა იყოს გენერირებული შემთხვევითად და შენახული საიდუმლოდ.",
          "დამატებითი შევსება: პრაქტიკაში, RSA ხშირად გამოიყენება დამატებითი შევსების სქემებთან ერთად, როგორიცაა OAEP, უსაფრთხოების გასაძლიერებლად.",
          "გვერდითი არხის შეტევები: იმპლემენტაციები უნდა იყოს ფრთხილი, რათა თავიდან აიცილოს ინფორმაციის გაჟონვა დროის ან ენერგიის მოხმარების გზით."
        ]
      },
      "practicalExample": {
        "title": "პრაქტიკული მაგალითი",
        "description": "განვიხილოთ მარტივი მაგალითი პატარა რიცხვებით (შენიშვნა: პრაქტიკაში გამოიყენება გაცილებით დიდი რიცხვები):",
        "steps": [
          "ავიღოთ p = 61 და q = 53",
          "დავთვალოთ n = 61 * 53 = 3233",
          "დავთვალოთ φ(n) = (61-1) * (53-1) = 3120",
          "ავიღოთ e = 17 (თანამარტივი 3120-თან)",
          "ვიპოვოთ ისეთი d, რომ (d * 17) mod 3120 = 1. d = 2753",
          "საჯარო გასაღებია (17, 3233), საიდუმლო გასაღები არის (2753, 3233)",
          "m = 123-ის დასაშიფრად: c = 123^17 mod 3233 = 855",
          "c = 855-ის გასაშიფრად: m = 855^2753 mod 3233 = 123"
        ]
      },
      "calculator": {
        "title": "RSA ალგორითმის კალკულატორი",
        "prime": "მარტივი რიცხვი",
        "generateKeys": "გასაღების გენერაცია",
        "publicKey": "საჯარო გასაღები",
        "privateKey": "საიდუმლო გასაღები",
        "encrypt": "დაშიფვრა",
        "decrypt": "გაშიფვრა",
        "encrypted": "დაშიფრული შეტყობინება",
        "decrypted": "გაშიფრული შეტყობინება",
        "messageToEncrypt": "დასაშიფრი შეტყობინება"
      }
    }
  },
  "graphTheory": {
    "introduction": {
      "title": "შესავალი გრაფთა თეორიაში",
      "graphDefinition": {
        "title": "გრაფის განმარტება",
        "definition": "გრაფი არის მათემატიკური სტრუქტურა, რომელიც შედგება ორი სიმრავლისგან:",
        "vertices": "V (წვეროები): ელემენტების არასაცარიელი სიმრავლე, რომელსაც ეწოდება წვეროები.",
        "edges": "E (წიბოები): სიმრავლე წვეროების წყვილებისა, რომლებიც მათ შორის კავშირს ასახავენ.",
        "formal": "მათემატიკურად, გრაფი ჩაიწერება როგორც: G = (V, E).",
        "explanation": "ზემოთ ნაჩვენებია მარტივი არამიმართული გრაფი, რომელსაც აქვს 6 წვერო და 9 წიბო.",
        "interactionPrompt": "თქვენ შეგიძლიათ დააწკაპუნოთ და გადაადგილოთ წიბოები!"
      },
      "graphDirectedness": {
        "title": "არამიმართული და მიმართული გრაფები",
        "definition": "გრაფები შეიძლება დავყოთ ორ ჯგუფად: არამიმართული და მიმართული, მათი წიბოების ბუნების მიხედვით:",
        "undirected": {
          "label": "არამიმართული გრაფი",
          "description": "წიბოებს არ აქვთ მიმართულება. კავშირი წვეროებს შორის სიმეტრიულია."
        },
        "directed": {
          "label": "მიმართული გრაფი",
          "description": "წიბოებს აქვთ მიმართულება. კავშირი წვეროებს შორის შეიძლება იყოს ასიმეტრიული."
        },
        "selectedEdge": "არჩეული წიბო: {{edge}}",
        "prompt": "დააწკაპუნეთ გრაფის წიბოზე, რათა ნახოთ განსხვავება ვიზუალურად.",
        "interactionPrompt": "დააწკაპუნეთ წიბოებზე ორივე გრაფში, რათა შეადაროთ არამიმართული და მიმართული გრაფები!"
      },
      "verticesAndEdges": {
        "title": "წვეროები და წიბოები",
        "description": "გრაფი შედგება ორი მთავარი ელემენტისგან:",
        "vertices": {
          "label": "წვეროები",
          "description": "წერტილები ან წრეები გრაფში"
        },
        "edges": {
          "label": "წიბოები",
          "description": "წიბოები, რომლებიც აკავშირებს წვეროებს"
        },
        "explanation": "მაგალითი: წრეები არის წვეროები. ხაზები, რომლებიც აკავშირებს ამ წვეროებს, არის წიბოები. მიმართულ გრაფში (მარჯვნივ), წვეროებს აქვს ისრები, რომლებიც მიუთითებს მიმართულებას.",
        "interactionPrompt": "დააწკაპუნეთ \"წვეროებს\" ან \"წიბოებს\" ზემოთ, რათა აღიქვათ ისინი!",
        "undirectedGraph": "არამიმართული გრაფი",
        "directedGraph": "მიმართული გრაფი"
      },
      "vertexDegree": {
        "title": "წვეროს ხარისხი",
        "description": "წვეროს ხარისხი არის წიბოების რაოდენობა, რომლებიც მასთან არის დაკავშირებული. სხვა სიტყვებით, ეს არის მეზობლების რაოდენობა, რომლებიც წვეროს ჰყავს.",
        "undirectedGraphDescription": "არამიმართული გრაფებისთვის, ეს უბრალოდ წვეროსთან დაკავშირებული წიბოების რაოდენობაა.",
        "directedGraphDescription": "მიმართულ გრაფებში, ჩვენ განვასხვავებთ შემომავალი და გამავალი წიბოების რაოდენობას.",
        "undirectedGraph": "არამიმართული გრაფი",
        "directedGraph": "მიმართული გრაფი",
        "undirectedDegreeExplanation": "არამიმართულ გრაფში {{selectedNode}} წვეროს ხარისხი არის {{undirectedDegree}}.",
        "directedDegreeExplanation": "მიმართულ გრაფში {{selectedNode}} წვეროს აქვს {{inDegree}} შემომავალი და {{outDegree}} გამავალი წიბო.",
        "selectVertexPrompt": "დააჭირეთ წვეროს ორივე გრაფში, რათა იხილოთ მისი ხარისხი.",
        "interactionPrompt": "დააჭირეთ სხვადასხვა წვეროს ორივე გრაფში, რათა შეადაროთ წვეროების ხარისხი არამიმართულ და მიმართულ გრაფებში!"
      },
      "pathsAndCycles": {
        "title": "გზები და ციკლები გრაფებში",
        "description": "გრაფთა თეორიაში გზები და ციკლები საბაზისო ცნებებია: გზა არის წვეროების თანმიმდევრობა, რომლებიც დაკავშირებულია წიბოებით, ყოველგვარი გამეორების გარეშე. ციკლი არის გზა, რომელიც იწყება და მთავრდება ერთი და იმავე წვეროთი.",
        "pathExplanation": "ეს არის გზა: e → f → g → a → b → c → d: ერთმანეთთან დაკავშირებული წვეროების თანმიმდევრობა გამეორების გარეშე.",
        "cycleExplanation": "ეს არის ციკლი: a → b → c → f → g → a. ის იწყება და მთავრდება ერთიდაიმავე წვეროთი.",
        "showPathButton": "გზის ჩვენება",
        "showCycleButton": "ციკლის ჩვენება",
        "interactiveDescription": "ააგეთ საკუთარი გრაფი, შემდეგ კი აღმოაჩინეთ ციკლები თქვენს გრაფში.",
        "resetButton": "გრაფის გადატვირთვა",
        "cyclesDetected": "გრაფში ნაპოვნი ციკლების რაოდენობა",
        "interactivePrompt": "დააწკაპუნეთ ეკრანზე წვეროების დასამატებლად. დააწკაპუნეთ ორ წვეროზე ზედიზედ მათ შორის წიბოს ასაგებად."
      },
      "graphConnectivity": {
        "title": "კავშირი გრაფებში",
        "description": "კავშირი გრაფებში განსხვავდება იმის მიხედვით, არის თუ არა ყველა წვერო დაკავშირებული ერთმანეთთან. გრაფი არის ბმული, თუ არსებობს გზა ყოველ წყვილ წვეროს შორის.",
        "connectedGraph": "ბმული გრაფი",
        "disconnectedGraph": "არაბმული გრაფი",
        "connectedExplanation": "ამ ბმულ გრაფში შეგიძლიათ მიწვდეთ ნებისმიერ წვეროს ნებისმიერი სხვა წვეროდან.",
        "disconnectedExplanation": "ამ არაბმულ გრაფში ორი ცალკეული კომპონენტია. თქვენ ვერ იპოვით გზას C ან D-დან A ან B-მდე.",
        "additionalInfo": "ბმულ გრაფს აქვს მხოლოდ ერთი კომპონენტი, მაშინ როცა არაბმული გრაფს აქვს ორი ან მეტი კომპონენტი. კომპონენტები ისეთი ქვეგრაფებია, სადაც ყველა წვერო დაკავშირებულია ერთმანეთთან, მაგრამ არაა დაკავშირებული სხვა კომპონენტების წვეროებთან."
      },
      "subgraphs": {
        "title": "ქვეგრაფები",
        "description": "ქვეგრაფი არის გრაფი, რომლის წვეროებისა და წიბოების სიმრავლე სხვა გრაფის ქვესიმრავლეა. ეს არის დიდი გრაფის პატარა ნაწილი, რომელშიც შენარჩუნებულია იგივე კავშირები, რაც თავდაპირველ გრაფში იყო.",
        "fullGraphExplanation": "ეს არის სრული გრაფი. ქვეგრაფი არის წვეროებისა და წიბოების ნაკრები ამ გრაფიდან.",
        "triangleExplanation": "ეს სამკუთხედი (A-B-C) არის ქვეგრაფი. მას აქვს ზოგიერთი, მაგრამ არა ყველა თავდაპირველი გრაფის წვერო და წიბო.",
        "pathExplanation": "ეს გზა (B-C-D-E) ასევე არის ქვეგრაფი. ის არის დაკავშირებული წვეროების მიმდევრობა, რომელიც შედის უფრო დიდ გრაფში.",
        "showFullGraph": "მაჩვენე სრული გრაფი",
        "showTriangle": "მაჩვენე სამკუთხედის ფორმის ქვეგრაფი",
        "showPath": "მაჩვენე გზის ფორმის ქვეგრაფი",
        "resetButton": "გადატვირთვა"
      }
    },
    "differentGraphs": {
      "title": "სხვადასხვა ტიპის გრაფები",
      "weightedGraphs": {
        "title": "წონიანი გრაფები",
        "description": "წონიანი გრაფებში თითოეულ წიბოს მინიჭებული აქვს რიცხვობრივი მნიშვნელობა, რომელსაც წონა ეწოდება. ეს წონები შეიძლება წარმოადგენდეს სხვადასხვა რეალურ რაოდენობას, როგორიცაა მანძილი ან ღირებულება. არსებობს წონიანი გრაფების ორი ძირითადი ტიპი:",
        "undirectedDescription": "არამიმართული წონიანი გრაფები: წიბოებს არ აქვთ მიმართულება და წონა მოქმედებს ორივე მიმართულებით დაკავშირებულ წვეროებს შორის.",
        "directedDescription": "მიმართული წონიანი გრაფები: წიბოებს აქვთ კონკრეტული მიმართულება და წონა მოქმედებს მხოლოდ ამ მიმართულებით.",
        "undirectedGraph": "არამიმართული წონიანი გრაფი",
        "directedGraph": "მიმართული წონიანი გრაფი",
        "edgeWeightExplanation": "არჩეულ წიბოს {{selectedElement}} აქვს წონა {{weight}}.",
        "nodeExplanation": "თქვენ აირჩიეთ წვერო {{selectedElement}}. წონიან გრაფში წონების ცნება დაკავშირებულია წიბოებთან და არა წვეროებთან.",
        "selectElementPrompt": "დააწკაპუნეთ წვეროზე ან წიბოზე მეტი ინფორმაციის სანახავად.",
        "interactionPrompt": "გაეცანით ზემოთ მოცემულ გრაფებ წონიანი გრაფების კონცეფციის უკეთ შესასწავლად. დააწკაპუნეთ წიბოებზე მათი წონების სანახავად, ან წვეროებზე წონიან გრაფებში მათი როლის გასაგებად."
      },
      "planarGraphs": {
        "planarTitle": "ბრტყელი გრაფები",
        "planarDescription": "ბრტყელი გრაფი არის ისეთი გრაფი, რომელიც სიბრტყეზე ისე შეიძლება დაიხატოს, რომ მისი წიბოები არსად გადაიკვეთოს, მხოლოდ წვეროსთან. ეს ნიშნავს, რომ წიბოები მხოლოდ მათი ბოლოებით ეხებიან ერთმანეთს.",
        "planarLabel": "ბრტყელი გრაფი",
        "nonPlanarLabel": "არაბრტყელი გრაფი",
        "planarInteractionPrompt": "შეცვალეთ წვეროების რაოდენობა და დააკვირდით როგორ იცვლება ბრტყელი და არაბრტყელი გრაფების ვიზუალი.",
        "numberOfNodes": "წვეროების რაოდენობა"
      },
      "bipartiteGraphs": {
        "title": "ორნაწილიანი გრაფი",
        "description": "ორნაწილიანი გრაფი არის გრაფი, რომლის წვეროები შეიძლება გაიყოს ორ განცალკევებულ სიმრავლედ ისე, რომ ყოველი წიბო აკავშირებდეს ერთი სიმრავლის წვეროს მეორე სიმრავლის წვეროსთან. სხვა სიტყვებით რომ ვთქვათ, არ არსებობს წიბოები ერთი და იმავე სიმრავლის წვეროებს შორის.",
        "bipartiteLabel": "ორნაწილიანი გრაფი",
        "examples": {
          "0": "სტუდენტები და კლასები: ერთი სიმრავლე წარმოადგენს სტუდენტებს, მეორე - კლასებს. წიბოები გვიჩვენებს, რომელი სტუდენტები არიან ჩარიცხულნი რომელ კლასებში.",
          "1": "მსახიობები და ფილმები: ერთი სიმრავლე მსახიობებისთვის, მეორე - ფილმებისთვის. წიბოები გვიჩვენებს, თუ რომელი მსახიობები მონაწილეობენ რომელ ფილმებში.",
          "2": "ავტორები და წიგნები: ერთი სიმრავლე ავტორებისთვის, მეორე - წიგნებისთვის. წიბოები წარმოადგენს, თუ რომელმა ავტორებმა დაწერეს რომელი წიგნები."
        },
        "applicationNote": "ეს მაგალითები აჩვენებს, თუ როგორ შეუძლიათ ორნაწილიან გრაფებს წარმოადგინონ ურთიერთობები ორი განსხვავებული ტიპის ობიექტებს შორის, რაც მათ ძლიერ ინსტრუმენტებად აქცევს სხვადასხვა სისტემებისა თუ ქსელების ანალიზისა და ვიზუალიზაციისთვის.",
        "nonBipartiteLabel": "არაორნაწილიანი გრაფი",
        "interactionPrompt": "შეცვალეთ ორივე გრაფში წვეროების რაოდენობა და დააკვირდით, როგორ ინარჩუნებს ორნაწილიანი გრაფი ყოველთვის წვეროების ორ განსხვავებულ სიმრავლეს, მაშინ როცა არაორნაწილიანი გრაფი უშვებს კავშირებს ერთი და იმავე სიმრავლის შიგნით.",
        "numberOfNodes": "წვეროების რაოდენობა"
      },
      "regularGraphs": {
        "title": "რეგულარული გრაფი",
        "description": "რეგულარული გრაფი არის გრაფი, სადაც თითოეულ წვეროს აქვს მეზობლების ერთნაირი რაოდენობა; სხვა სიტყვებით, ყველა წვეროს აქვს ერთი და იგივე ხარისხი. რეგულარული გრაფები ფუნდამენტურია გრაფთა თეორიაში და აქვთ სხვადასხვა გამოყენება ქსელების დიზაინში, ქიმიაში თუ სოციალური ქსელების ანალიზში.",
        "numberOfVertices": "წვეროების რაოდენობა",
        "degree": "ხარისხი",
        "oddEvenDescription": "წვეროების რაოდენობა და რეგულარული გრაფის ხარისხი მჭიდროდ არის დაკავშირებული. იმისათვის, რომ რეგულარული გრაფი არსებობდეს, წვეროების რაოდენობისა და ხარისხის ნამრავლი უნდა იყოს ლუწი. ეს იმიტომ, რომ თითოეული წიბო ორი წვეროს ხარისხში იანგარიშება. შედეგად, კენტი რაოდენობის წვეროების მქონე რეგულარულ გრაფებს უნდა ჰქონდეთ ლუწი ხარისხი, ხოლო ლუწი რაოდენობის წვეროების მქონე გრაფებს შეიძლება ჰქონდეთ როგორც კენტი, ისე ლუწი ხარისხი. გაეცანით ამ დამოკიდებულებებს ქვემოთ მოცემული წვეროების რაოდენობისა და ხარისხის რეგულირებით.",
        "interactionPrompt": "გამოიყენეთ ქვემოთ მოცემული ღილაკები წვეროების რაოდენობისა და ხარისხის შესაცვლელად. დააკვირდით, როგორ იცვლება რეგულარული გრაფი და რომელი კომბინაციებია შესაძლებელი ან შეუძლებელი."
      },
      "completeGraphs": {
        "title": "სრული გრაფი",
        "description": "სრული გრაფი არის გრაფი, რომელშიც ყოველი წყვილი განსხვავებული წვერო დაკავშირებულია უნიკალური წიბოთი. n წვეროს მქონე სრულ გრაფში თითოეულ წვეროს აქვს n-1 ხარისხი, ხოლო წიბოების საერთო რაოდენობა არის n(n-1)/2.",
        "interactionPrompt": "გამოიყენეთ ქვემოთ მოცემული ღილაკები წვეროების რაოდენობის შესაცვლელად. დააკვირდით, როგორ იცვლება წიბოების რაოდენობა და თითოეული წვეროს ხარისხი გრაფის მოდიფიცირებისას.",
        "numberOfVertices": "წვეროების რაოდენობა",
        "edgeCount": "წიბოების რაოდენობა: {{num}}",
        "degreeProp": "თითოეული წვეროს ხარისხი: {{degree}}"
      },
      "trees": {
        "title": "ხეები",
        "description": "გრაფთა თეორიაში, ხე არის ბმული, აციკლური გრაფი. ხეები გამოიყენება იერარქიების წარმოსადგენად და ეფექტური ალგორითმების შესაქმნელად.",
        "tree1": "ორობითი ხე",
        "tree1Explanation": "ორობითი ხე არის ხე, რომელშიც თითოეულ წვეროს ჰყავს მაქსიმუმ ორი შვილი. ხშირად გამოიყენება ეფექტური ძებნისა და დახარისხების ალგორითმებისთვის.",
        "tree2": "ზოგადი ხე",
        "tree2Explanation": "ზოგადი ხე, რომელშიც წვეროებს შეიძლება ჰყავდეთ ნებისმიერი რაოდენობის შვილი. სასარგებლოა რთული იერარქიების წარმოსადგენად, როგორიცაა ფაილური სისტემები ან ორგანიზაციული სქემები.",
        "interactionPrompt": "დაათვალიერეთ მოცემული ორი ტიპის ხე."
      }
    },
    "graphTraversals": {
      "title": "ძიება გრაფში",
      "bfs": {
        "title": "სიგანეში ძებნა",
        "explanation": "სიგანეში ძიება (BFS) ჰგავს ქალაქის კვარტალ-კვარტალ შესწავლას. წარმოიდგინეთ, რომ დგახართ თქვენს სახლთან (საწყისი წვერო) და გსურთ კონკრეტული ადგილის პოვნა. ნაცვლად იმისა, რომ ერთ გრძელ ქუჩაზე იაროთ, თქვენ ჯერ ეწვევით ყველა ადგილს თქვენს კვარტალში. შემდეგ გადადიხართ ყველა ისეთ ადგილას, რომელიც ერთი კვარტლის დაშორებითაა, შემდეგ ორი კვარტლის დაშორებით და ა.შ. ამგვარად, თქვენ დარწმუნებული ხართ, რომ ჯერ უახლოეს ადგილს წააწყდებით. გრაფების ტერმინებში, BFS იწყება არჩეული წვეროდან და იკვლევს ყველა მის მეზობელს, სანამ შემდეგ დონეზე გადავა. ის იყენებს რიგს (პროგრამირებაში Queue - ანალოგიურია ჩვეულებრივი რიგისა, პირველად მისული პირველად გადის რიგიდან) იმის დასამახსოვრებლად, თუ რომელი წვეროები უნდა მოინახულოს შემდეგ. ეს მეთოდი უზრუნველყოფს, რომ წვეროები მიიღწევა მათი საწყისი წერტილიდან დაშორების მიხედვით, რაც BFS-ს იდეალურს ხდის ორ წერტილს შორის უმოკლესი გზის საპოვნელად არაწონიან გრაფში. BFS ფართოდ გამოიყენება ისეთ აპლიკაციებში, როგორიცაა სოციალური ქსელები, GPS ნავიგაცია ახლომდებარე ადგილების საპოვნელად და თავსატეხების ამოხსნის ალგორითმებშიც კი!",
        "demoDescription": "უყურეთ ქვემოთ მოცემულ ანიმაციას, რათა ნახოთ, როგორ მოივლის BFS გრაფს სართულ-სართულ:",
        "interactionDescription": "ახლა სცადეთ საკუთარი გრაფის შექმნა და გაუშვით BFS, რომ ნახოთ, როგორ მუშაობს ის სხვადასხვა სტრუქტურებზე:",
        "interactionPrompt": "დააწკაპუნეთ ცარიელ სივრცეზე წვეროების დასამატებლად. დააწკაპუნეთ ზედიზედ ორ წვეროზე წიბოს შესაქმნელად. დააწკაპუნეთ წვეროზე, რომ მონიშნოთ ის საწყის წვეროდ (წვერო მწვანედ მოინიშნება). დააჭირეთ play ღილაკს BFS-ის დასაწყებად.",
        "unvisitedNode": "გავლილი წვერო",
        "visitedNode": "გაუვლელი წვერო",
        "currentNode": "მიმდინარე წვერო",
        "queuedNode": "რიგში მყოფი წვერო",
        "traversedEdge": "გავლილი წიბო"
      },
      "dfs": {
        "title": "სიღრმეში ძებნა",
        "explanation": "სიღრმეში ძებნა (DFS) ჰგავს ლაბირინთის კვლევას, როდესაც ყოველთვის ირჩევთ ყველაზე ღრმა გამოუკვლევ გზას. წარმოიდგინეთ, რომ ხართ მღვიმეთა სისტემაში: თქვენ აგრძელებთ სვლას გამოუკვლევ გვირაბებში, სანამ ჩიხს არ მიაღწევთ, შემდეგ კი უკან ბრუნდებით ბოლო გასაყარამდე, იქიდან კი გზას ისევ სიღრმეში აგრძელებთ. ეს მეთოდი უზრუნველყოფს, რომ ყველა შესაძლო გზა გამოიკვლიოთ.",
        "demoDescription": "უყურეთ ქვემოთ მოცემულ ანიმაციას, რომ ნახოთ, როგორ მოივლის DFS გრაფს, რომელიც ყოველთვის აირჩევს მარცხენა გამოუკვლევ გზას მაქსიმალური დაშორებით:",
        "interactionDescription": "ახლა სცადეთ საკუთარი გრაფის შექმნა და გაუშვით DFS, რომ ნახოთ, როგორ მუშაობს ის სხვადასხვა სტრუქტურებზე:",
        "interactionPrompt": "დააწკაპუნეთ წვეროების დასამატებლად. დააწკაპუნეთ ორ წვეროზე კავშირის შესაქმნელად. დააწკაპუნეთ წვეროზე, რომ დააყენოთ საწყისად. დააჭირეთ play ღილაკს DFS-ის დასაწყებად.",
        "unvisitedNode": "გავლილი წვერო",
        "visitedNode": "მონახულებული წვერო",
        "currentNode": "მიმდინარე წვერო",
        "stackNode": "მომლოდინე წვერო",
        "forwardEdge": "გავლილი წიბო",
        "runDFS": "DFS-ის გაშვება",
        "resetGraph": "გრაფის განულება"
      }
    },
    "graphAlgorithms": {
      "title": "გრაფების ალგორითმები",
      "graphIsomorphism": {
        "title": "გრაფების იზომორფიზმი",
        "introduction": "გრაფების იზომორფიზმი არის ფუნდამენტური ცნება გრაფთა თეორიაში, რომელიც გვეხმარება გავიგოთ, როდის აქვს ორ გრაფს ერთნაირი სტრუქტურა, მიუხედავად იმისა, თუ როგორ არიან ისინი გამოსახუები ან როგორაა მათი წვეროები დასახელებული.",
        "definitionTitle": "რა არის გრაფების იზომორფიზმი?",
        "definition": "ორი გრაფი G და H ითვლება იზომორფულად, თუ არსებობს ბიექციური ფუნქცია f G-ს წვეროებიდან H-ის წვეროებზე ისე, რომ ნებისმიერი ორი წვერო u და v მეზობლები არიან G-ში მაშინ და მხოლოდ მაშინ, როცა f(u) და f(v) მეზობლები არიან H-ში. მარტივად რომ ვთქვათ, იზომორფულ გრაფებს აქვთ ერთნაირი სტრუქტურა და შეიძლება ერთმანეთში გარდაიქმნან წვეროების გადარქმევით.",
        "determinationTitle": "როგორ განვსაზღვროთ იზომორფიზმი",
        "determination": "ორი გრაფის იზომორფულობის განსაზღვრა საკმაოდ რთული პროცესია. ამ პროცესის რამდენიმე მთავარი ნაბიჯი: 1. შეამოწმეთ, აქვთ თუ არა გრაფებს წვეროებისა და წიბოების ერთნაირი რაოდენობა. 2. შეადარეთ ორივე გრაფის წვეროების ხარისხების მიმდევრობა. 3. მოძებნეთ ერთნაირი სიგრძის ციკლები ორივე გრაფში. 4. შეამოწმეთ მსგავსი ქვეგრაფების არსებობა. თუმცა, ეს პირობები აუცილებელია, მაგრამ არასაკმარისი. იზომორფიზმის დასამტკიცებლად ერთადერთი გზაა წვეროებს შორის ბიექციური ასახვის პოვნა.",
        "exampleDescription": "ქვემოთ მოცემულია ორი იზომორფული გრაფი. მიუხედავად იმისა, რომ ისინი განსხვავებულად გამოიყურებიან, მათ აქვთ ერთნაირი სტრუქტურა.",
        "isomorphicResult": "გრაფები იზომორფულია! მათ აქვთ ერთნაირი სტრუქტურა, მიუხედავად შესაძლო განსხვავებული განლაგებისა ან დასახელებებისა.",
        "nonIsomorphicResult": "გრაფები არ არის იზომორფული. მათ აქვთ განსხვავებული სტრუქტურები.",
        "interactiveDescription": "დააწკაპუნეთ გრაფის არეზე წვეროების დასამატებლად. დააწკაპუნეთ ორ წვეროზე თანმიმდევრობით მათ შორის წიბოს შესაქმნელად. გამოიყენეთ ქვემოთ მოცემული ღილაკები იზომორფიზმის შესამოწმებლად ან უკვე აგებული გრაფების წასაშლელად."
      },
      "spanningTree": {
        "title": "გრაფის დამფარავი ხეები",
        "introduction": "დამფარავი ხე არის გრაფთა თეორიის ფუნდამენტური ცნება, რომელსაც მნიშვნელოვანი გამოყენება აქვს ქსელების დიზაინში, წრედების ანალიზსა და ალგორითმებში. ეს სექცია დაგეხმარებათ გაიგოთ, როგორ მუშაობს დამფარავი ხეები და როგორ ხდება მათი აგება.",
        "definitionTitle": "რა არის დამფარავი ხე?",
        "definition": "არამიმართული გრაფის დამფარავი ხე არის ქვეგრაფი, რომელიც მოიცავს თავდაპირველი გრაფის ყველა წვეროს, მინიმალური რაოდენობის წიბოებით, რაც საჭიროა ხის (აცილკური ბმული გრაფი) შესაქმნელად. სხვა სიტყვებით რომ ვთქვათ, დამფარავი ხე აღწევს ყველა წვეროს ციკლების გარეშე.",
        "algorithmTitle": "როგორ ვიპოვოთ დამფარავი ხე",
        "algorithm": "არსებობს რამდენიმე ალგორითმი დამფარავი ხის საპოვნელად. ერთ-ერთი გავრცელებული მიდგომაა სიგანეში ძებნის (BFS) გამოყენება: 1. დაიწყეთ გრაფის ნებისმიერი წვეროდან. 2. შეისწავლეთ ყველა მოუნახულებელი მეზობელი წვერო. 3. ყოველი მოუნახულებელი მეზობლისთვის, დაამატეთ დამფარავ ხეში წიბო, რომელიც მას აკავშირებს მიმდინარე წვეროსთან. 4. გაიმეორეთ ნაბიჯები 2 და 3 სანამ ყველა წვერო არ იქნება მონახულებული. ეს პროცესი უზრუნველყოფს, რომ მივაღწიოთ ყველა წვეროს მინიმალური რაოდენობის წიბოებით, რაც ქმნის ვალიდურ დამფარავ ხეს.",
        "exampleDescription": "აი, მაგალითი გრაფი გამოყოფილი დამფარავი ხით. ფირუზისფერი წვეროები და ნარინჯისფერი წიბოები წარმოადგენენ დამფარავ ხეს.",
        "exampleExplanation": "ამ მაგალითში გვაქვს გრაფი 8 წვეროთი (A-დან H-მდე) და 12 წიბოთი. გამოყოფილი დამფარავი ხე შეიცავს 7 წიბოს, რაც არის მინიმალური რაოდენობა, რომელიც საჭიროა ყველა 8 წვეროს დასაკავშირებლად ციკლების წარმოქმნის გარეშე. შენიშნეთ, როგორ აღწევს დამფარავი ხე გრაფის ყველა წვეროს, მაგრამ თავდაპირველი გრაფის ზოგიერთი წიბო არ არის დამფარავი ხის ნაწილი. ეს აჩვენებს, თუ როგორ ინარჩუნებს დამფარავი ხე კავშირს გამოყენებული წიბოების რაოდენობის მინიმიზაციის დროს.",
        "interactiveDescription": "ახლა თქვენი ჯერია! დააწკაპუნეთ გრაფის არეზე წვეროების დასამატებლად. დააწკაპუნეთ ორ წვეროზე თანმიმდევრობით მათ შორის წიბოს შესაქმნელად. გამოიყენეთ 'გაშვების' ღილაკი დამფარავი ხის საპოვნელად და 'წაშლის' ღილაკი გრაფის გასასუფთავებლად.",
        "spanningTreeFound": "დამფარავი ხე ნაპოვნია!",
        "spanningTreeFoundDescription": "გრაფის დამფარავი ხე წარმატებით იქნა ნაპოვნი.",
        "spanningTreeNotFound": "დამფარავი ხე ვერ მოიძებნა",
        "spanningTreeNotFoundDescription": "დამფარავი ხე ვერ მოიძებნა. ეს ხდება, როდესაც გრაფი არ არის ბმული (ანუ, არსებობს იზოლირებული წვეროები ან ქვეგრაფები)."
      },
      "graphColoring": {
        "title": "გრაფის გაფერადება",
        "introduction": "გრაფის გაფერადება არის გრაფთა თეორიის ფუნდამენტური ცნება, რომელსაც აქვს მრავალი პრაქტიკული გამოყენება.",
        "definitionTitle": "განმარტება",
        "definition": "გრაფის გაფერადება არის გრაფის წვეროებისთვის ფერების მინიჭება ისე, რომ არცერთი ორი მეზობელი წვერო არ იყოს ერთი და იმავე ფერის.",
        "algorithmTitle": "ალგორითმი",
        "algorithm": "გრაფის გაფერადების მარტივი ხარბი ალგორითმი მუშაობს წვეროების გავლით და ანიჭებს მათ პირველ ხელმისაწვდომ ფერს, რომელიც არ გამოყენებულა მეზობელ წვეროებზე.",
        "exampleDescription": "აი, მარტივი გრაფი, რომელიც აჩვენებს გაფერადების ალგორითმს:",
        "exampleExplanation": "შენიშნეთ, რომ არცერთი დაკავშირებული წვერო არ იზიარებს ერთსა და იმავე ფერს.",
        "interactiveDescription": "ააგეთ საკუთარი გრაფი. დაწკაპუნეთ წვეროს დასამატებლად. დააწკაპუნეთ ორ წვეროზე მათ შორის წიბოს შესაქმნელად. შემდეგ გამოიყენეთ ქვემოთ მოცემული ღილაკები გრაფის გასაფერადებლად ან წასაშლელად.",
        "resultTitle": "გაფერადების შედეგი",
        "resultDescription": "გრაფი წარმატებით გაფერადდა. დააკვირდით, როგორ დაიყვანა მინიმუმამდე ალგორითმმა გამოყენებული ფერების რაოდენობა, ამავდროულად უზრუნველყო, რომ მეზობელ წვეროებს არ ჰქონდეთ ერთი და იგივე ფერი.",
        "usedColors": "გამოყენებული ფერების რაოდენობა: {{count}}"
      }
    },
    "graphProblems": {
      "title": "გრაფთა თეორიის ამოცანები"
    }
  }
}
